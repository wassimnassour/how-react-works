"use strict";(self.webpackChunkhowreactworks=self.webpackChunkhowreactworks||[]).push([[832],{7522:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var o=t(9901);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},f="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),f=c(t),m=r,d=f["".concat(l,".").concat(m)]||f[m]||p[m]||a;return t?o.createElement(d,i(i({ref:n},u),{},{components:t})):o.createElement(d,i({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[f]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3265:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=t(3909),r=(t(9901),t(7522));const a={sidebar_position:12},i="How Commit works",s={unversionedId:"react-dom/how.commit.works",id:"react-dom/how.commit.works",title:"How Commit works",description:"The commit will occur when render finishes either for the first time from",source:"@site/docs/react-dom/12.how.commit.works.md",sourceDirName:"react-dom",slug:"/react-dom/how.commit.works",permalink:"/how-react-works/docs/react-dom/how.commit.works",draft:!1,editUrl:"https://github.com/incepter/how-react-works/edit/main/packages/howreactworks/docs/react-dom/12.how.commit.works.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"reactSidebar",previous:{title:"How completeWork works",permalink:"/how-react-works/docs/react-dom/how.complete_work.works"}},l={},c=[{value:"How finishing concurrent render works",id:"how-finishing-concurrent-render-works",level:2},{value:"Signature",id:"signature",level:3},{value:"Implementation steps",id:"implementation-steps",level:3},{value:"How Commit work when ready works",id:"how-commit-work-when-ready-works",level:2},{value:"Signature",id:"signature-1",level:3},{value:"Implementation steps",id:"implementation-steps-1",level:3},{value:"How <code>commitRoot</code> works:",id:"how-commitroot-works",level:2},{value:"Reset some <code>root</code> properties",id:"reset-some-root-properties",level:3},{value:"Schedule passive effects if applied",id:"schedule-passive-effects-if-applied",level:3},{value:"Execute Effects",id:"execute-effects",level:3},{value:"1. Before mutation effects",id:"1-before-mutation-effects",level:4},{value:"2. Mutation effects",id:"2-mutation-effects",level:4},{value:"3. Layout effects",id:"3-layout-effects",level:4},{value:"4. Passive effects",id:"4-passive-effects",level:4}],u={toc:c},f="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(f,(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-commit-works"},"How Commit works"),(0,r.kt)("p",null,"The commit will occur when render finishes either for the first time from\n",(0,r.kt)("inlineCode",{parentName:"p"},"root.render()")," or on updates. We will discuss first when coming from the first\nrender."),(0,r.kt)("h2",{id:"how-finishing-concurrent-render-works"},"How finishing concurrent render works"),(0,r.kt)("p",null,"After your initial application render and all the mechanics we've seen before,\nReact will call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"finishConcurrentRender(root, exitStatus, finishedWork, lanes);\n")),(0,r.kt)("h3",{id:"signature"},"Signature"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1055"},(0,r.kt)("inlineCode",{parentName:"a"},"finishConcurrentRender")),"\nis defined as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function finishConcurrentRender(\n  root: FiberRoot,\n  exitStatus: RootExitStatus,\n  finishedWork: Fiber,\n  lanes: Lanes,\n) {\n  // [...code]\n  commitRootWhenReady(\n    root,\n    finishedWork,\n    workInProgressRootRecoverableErrors,\n    workInProgressTransitions,\n    lanes,\n  );\n  // [...code]\n}\n")),(0,r.kt)("h3",{id:"implementation-steps"},"Implementation steps"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Switch over the ",(0,r.kt)("inlineCode",{parentName:"p"},"exitStatus"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"switch(existStatus) {\n  case RootInProgress:\n  case RootFatalErrored: {\n    // defensive guard\n    throw new Error('Root did not complete. This is a bug in React.');\n  }\n\n  case RootErrored:\n  case RootSuspended:\n  case RootCompleted: {\n    // continue function execution\n    break;\n  }\n  default: {\n    throw new Error('Unknown root exit status.');\n  }\n\n  case RootSuspendedWithDelay: {\n    if (includesOnlyTransitions(lanes)) {\n      markRootSuspended(root, lanes);\n      // this function will only mark root suspended and quit in this case\n      // highlight-next-line\n      return;\n    }\n    break;\n }\n}\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"When root is suspended and only on retries, then:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"if (\n   includesOnlyRetries(lanes) &&\n   (alwaysThrottleRetries || exitStatus === RootSuspended)\n ) {\n  // ...\n}\n")),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Compute the milliseconds until timeout and ignore timeouts less than 10 millis",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\nif (msUntilTimeout > 10) {\n  // ...\n}\n"))),(0,r.kt)("li",{parentName:"ol"},"Compute ",(0,r.kt)("inlineCode",{parentName:"li"},"nextLanes")," and quit the function if there is no work; remember,\nthis path is when the render suspended and only when React\nis retrying the render.",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const nextLanes = getNextLanes(root, NoLanes);\nif (nextLanes !== NoLanes) {\n   return;\n}\n"))),(0,r.kt)("li",{parentName:"ol"},"schedule a timeout via ",(0,r.kt)("inlineCode",{parentName:"li"},"setTimeout")," to commit the root when ready and quit:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"root.timeoutHandle = scheduleTimeout(\n  commitRootWhenReady.bind(\n    null,\n    root,\n    finishedWork,\n    workInProgressRootRecoverableErrors,\n    workInProgressTransitions,\n    lanes,\n  ),\n  msUntilTimeout,\n);\nreturn;\n")),"This will commit the root to show the suspense fallback \ud83d\ude09"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Otherwise, when root isn't suspended and completed successfully, then it will\ncall ",(0,r.kt)("inlineCode",{parentName:"p"},"commitRootWhenReady")," right away:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"commitRootWhenReady(\n  root,\n  finishedWork,\n  workInProgressRootRecoverableErrors,\n  workInProgressTransitions,\n  lanes,\n);\n")))),(0,r.kt)("h2",{id:"how-commit-work-when-ready-works"},"How Commit work when ready works"),(0,r.kt)("p",null,"The real commit happens at the ",(0,r.kt)("inlineCode",{parentName:"p"},"commitRoot")," function that we will see in a few,\nbut it is always called from ",(0,r.kt)("inlineCode",{parentName:"p"},"commitRootWhenReady")," for concurrent renders,\nsync render from ",(0,r.kt)("inlineCode",{parentName:"p"},"performSyncWorkOnRoot")," will call ",(0,r.kt)("inlineCode",{parentName:"p"},"commitRoot")," independently."),(0,r.kt)("h3",{id:"signature-1"},"Signature"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1147"},(0,r.kt)("inlineCode",{parentName:"a"},"commitRootWhenReady")),"\nis defined as follows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function commitRootWhenReady(\n  root: FiberRoot,\n  finishedWork: Fiber,\n  recoverableErrors: Array<CapturedValue<mixed>> | null,\n  transitions: Array<Transition> | null,\n  lanes: Lanes,\n) {\n  // ...\n}\n")),(0,r.kt)("h3",{id:"implementation-steps-1"},"Implementation steps"),(0,r.kt)("p",null,"This function will call commitRoot immediately if it is called with an urgent\nlane:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"if (includesOnlyNonUrgentLanes(lanes)) {\n  // ... code\n  return;\n}\ncommitRoot(root, recoverableErrors, transitions);\n")),(0,r.kt)("p",null,"Urgent lanes are as ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L465"},"per the definition:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\nreturn (lanes & UrgentLanes) === NoLanes;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SyncLane")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"InputContinuousLane")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"DefaultLane"))),(0,r.kt)("p",null,"So coming from root.render() will be in a DefaultLane and thus considered as\nurgent and will call ",(0,r.kt)("inlineCode",{parentName:"p"},"commitRoot"),"."),(0,r.kt)("p",null,"When all lanes aren't urgent, React will perform a ",(0,r.kt)("inlineCode",{parentName:"p"},"Suspensey commit")," by\nscheduling the commit for later:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"if (includesOnlyNonUrgentLanes(lanes)) {\n  startSuspendingCommit();\n  accumulateSuspenseyCommit(finishedWork);\n  const schedulePendingCommit = waitForCommitToBeReady();\n  if (schedulePendingCommit !== null) {\n    root.cancelPendingCommit = schedulePendingCommit(\n      commitRoot.bind(null, root, recoverableErrors, transitions),\n    );\n    markRootSuspended(root, lanes);\n    return;\n  }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"The previous code isn't explained in this section to keep it short.\nIf you are curious about it and want it explained, please open an issue.")),(0,r.kt)("h2",{id:"how-commitroot-works"},"How ",(0,r.kt)("inlineCode",{parentName:"h2"},"commitRoot")," works:"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2577"},(0,r.kt)("inlineCode",{parentName:"a"},"commitRoot")),"\nitself will make a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"commitRootImpl")," like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function commitRoot(\n  root: FiberRoot,\n  recoverableErrors: null | Array<CapturedValue<mixed>>,\n  transitions: Array<Transition> | null,\n) {\n  const previousUpdateLanePriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    // highlight-next-line\n    commitRootImpl(\n      root,\n      recoverableErrors,\n      transitions,\n      previousUpdateLanePriority,\n    );\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n    setCurrentUpdatePriority(previousUpdateLanePriority);\n  }\n\n  return null;\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2604"},(0,r.kt)("inlineCode",{parentName:"a"},"commitRootImpl")," function"),"\nis very long and complex and will call many other functions and many recursions."),(0,r.kt)("p",null,"It will be a very long section full of information and complex code, get ready!"),(0,r.kt)("p",null,"Here is a very long simplified version of what we will see next (Sorry, I had to\nput it in a ",(0,r.kt)("inlineCode",{parentName:"p"},"details")," tag):"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Simplified long commitRootImpl"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified, a lot\nfunction commitRootImpl(\n  root: FiberRoot,\n  recoverableErrors: null | Array<CapturedValue<mixed>>,\n  transitions: Array<Transition> | null,\n  renderPriorityLevel: EventPriority,\n) {\n  \n  do {\n    // well, commitRoot may be triggerred while we have a scheduled pending\n    // effects processing.\n    // in this case, we need to pass over them now.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n  \n  const finishedWork = root.finishedWork;\n  const lanes = root.finishedLanes;\n\n  if (finishedWork === null) {\n    return null;\n  }\n\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  if (finishedWork === root.current) {\n    throw new Error(\n      'Cannot commit the same tree as before. This error is likely caused by ' +\n      'a bug in React. Please file an issue.',\n    );\n  }\n\n  root.callbackNode = null;\n  root.callbackPriority = NoLane;\n  root.cancelPendingCommit = null;\n\n\n  let remainingLanes = mergeLanes(\n    finishedWork.lanes | finishedWork.childLanes,\n    getConcurrentlyUpdatedLanes(),\n  );\n  markRootFinished(root, remainingLanes);\n\n  if (root === workInProgressRoot) {\n    workInProgressRoot = null;\n    workInProgress = null;\n    workInProgressRootRenderLanes = NoLanes;\n  }\n   \n  if (\n    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||\n    (finishedWork.flags & PassiveMask) !== NoFlags\n  ) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      pendingPassiveEffectsRemainingLanes = remainingLanes;\n      pendingPassiveTransitions = transitions;\n      // highlight-next-line\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n\n  const subtreeHasEffects =\n    (finishedWork.subtreeFlags &\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n  const rootHasEffect =\n    (finishedWork.flags & \n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n\n\n  if (subtreeHasEffects || rootHasEffect) {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = null;\n    const previousPriority = getCurrentUpdatePriority();\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext;\n\n    ReactCurrentOwner.current = null;\n    const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(\n      root,\n      finishedWork,\n    );\n\n    // The next phase is the mutation phase, where we mutate the host tree.\n    commitMutationEffects(root, finishedWork, lanes);\n    resetAfterCommit(root.containerInfo);\n\n    // highlight-next-line\n    root.current = finishedWork;\n\n    // highlight-next-line\n    commitLayoutEffects(finishedWork, root, lanes);\n    \n    requestPaint();\n\n    executionContext = prevExecutionContext;\n\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  } else {\n     // No effects.\n     root.current = finishedWork;\n  }\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsLanes = lanes;\n  } else {\n    releaseRootPooledCache(root, remainingLanes);\n  }\n\n  // Read this again, since an effect might have updated it\n  remainingLanes = root.pendingLanes;\n\n  if (remainingLanes === NoLanes) {\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  ensureRootIsScheduled(root);\n  \n  if (recoverableErrors !== null) {\n    // remember this? createRoot options \ud83d\ude09\n    const onRecoverableError = root.onRecoverableError;\n    for (let i = 0; i < recoverableErrors.length; i++) {\n      const recoverableError = recoverableErrors[i];\n      const errorInfo = makeErrorInfo(\n        recoverableError.digest,\n        recoverableError.stack,\n      );\n      onRecoverableError(recoverableError.value, errorInfo);\n    }\n  }\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  if (includesSyncLane(pendingPassiveEffectsLanes) && root.tag !== LegacyRoot) {\n     // highlight-next-line\n     flushPassiveEffects();\n  }\n\n  // Read this again, since a passive effect might have updated it\n  remainingLanes = root.pendingLanes;\n  if (includesSyncLane(remainingLanes)) {\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  // highlight-next-line\n  flushSyncWorkOnAllRoots();\n\n  return null;\n}\n"))),(0,r.kt)("p",null,"Let's put this into human-readable words:"),(0,r.kt)("p",null,"This step's purpose is to invoke many stages of effects that will result in\ndisplaying the result of your application on the screen."),(0,r.kt)("h3",{id:"reset-some-root-properties"},"Reset some ",(0,r.kt)("inlineCode",{parentName:"h3"},"root")," properties"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const finishedWork = root.finishedWork;\n\nroot.finishedWork = null;\nroot.finishedLanes = NoLanes;\n\nroot.callbackNode = null;\nroot.callbackPriority = NoLane;\nroot.cancelPendingCommit = null;\n\nroot.current = finishedWork;\n\nif (root === workInProgressRoot) {\n  workInProgressRoot = null;\n  workInProgress = null;\n  workInProgressRootRenderLanes = NoLanes;\n}\n// later\n")),(0,r.kt)("h3",{id:"schedule-passive-effects-if-applied"},"Schedule passive effects if applied"),(0,r.kt)("p",null,"React smartly tags the tree to know whether it has effects on it, and when they\nexist, it will schedule a callback to process them later"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"if (\n  (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||\n  (finishedWork.flags & PassiveMask) !== NoFlags\n) {\n  if (!rootDoesHavePassiveEffects) {\n    rootDoesHavePassiveEffects = true;\n    pendingPassiveEffectsRemainingLanes = remainingLanes;\n    pendingPassiveTransitions = transitions;\n    // highlight-start\n    scheduleCallback(NormalSchedulerPriority, () => {\n      flushPassiveEffects();\n      return null;\n    });\n    // highlight-end\n  }\n}\n")),(0,r.kt)("p",null,"This callback will be executed asynchronously which will leave the time for\nReact to execute other effects types."),(0,r.kt)("h3",{id:"execute-effects"},"Execute Effects"),(0,r.kt)("p",null,"React supports many types of effects, so they are assembled and executed here."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const subtreeHasEffects =\n  (finishedWork.subtreeFlags &\n    (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n  NoFlags;\nconst rootHasEffect =\n  (finishedWork.flags &\n    (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n  NoFlags;\n\n\nif (rootHasEffect || subtreeHasEffects) {\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = null;\n  const previousPriority = getCurrentUpdatePriority();\n  setCurrentUpdatePriority(DiscreteEventPriority);\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  ReactCurrentOwner.current = null;\n   \n  \n  // highlight-next-line\n  commitBeforeMutationEffects(root, finishedWork);\n  // highlight-next-line\n  commitMutationEffects(root, finishedWork, lanes);\n  resetAfterCommit(root.containerInfo);\n  // highlight-next-line\n  root.current = finishedWork;\n  // highlight-next-line\n  commitLayoutEffects(finishedWork, root, lanes);\n  // highlight-next-line\n  requestPaint();\n  \n  \n  executionContext = prevExecutionContext;\n  setCurrentUpdatePriority(previousPriority);\n  ReactCurrentBatchConfig.transition = prevTransition;\n}\n\nif (recoverableErrors !== null) {\n  // createRoot onRecoverableError option\n  callRootOnRecoverableErrors(root);\n}\n\nif (hasUncaughtError) {\n  hasUncaughtError = false;\n  const error = firstUncaughtError;\n  firstUncaughtError = null;\n  throw error;\n}\n\n\n// highlight-next-line\nif (includesSyncLane(pendingPassiveEffectsLanes) && root.tag !== LegacyRoot) {\n  // highlight-next-line\n  flushPassiveEffects();\n// highlight-next-line\n}\n\n// [...] rest of commit root\n")),(0,r.kt)("p",null,"React has and will execute the following effects in order:"),(0,r.kt)("h4",{id:"1-before-mutation-effects"},"1. Before mutation effects"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCommitWork.js#L372"},"This effect"),"\nwill trigger lifecycle events work before mutating the previous tree."),(0,r.kt)("p",null,"It is used for example ",(0,r.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/Component#getsnapshotbeforeupdate"},"to call ",(0,r.kt)("inlineCode",{parentName:"a"},"getSnapshotBeforeUpdate")),"\nfor class components and/or the experimental ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffectEvent"),"."),(0,r.kt)("p",null,"The full switch work can be ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCommitWork.js#L441"},"found here")),(0,r.kt)("h4",{id:"2-mutation-effects"},"2. Mutation effects"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCommitWork.js#L2541"},"Mutation effects"),"\nwill the perform and execute the following:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Deletion effects"),": Call deleted components ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCommitWork.js#L2020"},"effects cleanups.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Reconciliation effects"),": Insert the new dom nodes in their ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCommitWork.js#L1808"},"correct places.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Update effects"),": Or mutation effects. React here will ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-dom-bindings/src/client/ReactFiberConfigDOM.js#L690"},"update the dom node"),"\nwith new values from the current render."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Insertion effects cleanups"),": ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCommitWork.js#L2562"},(0,r.kt)("inlineCode",{parentName:"a"},"useInsertionEffect")," cleanup.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Insertion effects"),": ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCommitWork.js#L2567"},(0,r.kt)("inlineCode",{parentName:"a"},"useInsertionEffect"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Layout effects cleanups"),": Call Layout effects cleanups. Read ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCommitWork.js#L2574"},"Andrew's comment"),"\nto know more.")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Gotchas:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"Layout and passive effects are executed ",(0,r.kt)("inlineCode",{parentName:"li"},"bottom-to-up"),"."),(0,r.kt)("li",{parentName:"ul"},"Layout and passive effects cleanup are executed ",(0,r.kt)("inlineCode",{parentName:"li"},"up-to-bottom"),"."),(0,r.kt)("li",{parentName:"ul"},"Layout and passive effects cleanup are executed as a whole before the actual\neffects: loop and call the cleanups from the up to bottom, then when you finish\ncleanups, call the effects from bottom to up."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"useInsertionEffect")," doesn't follow the same order as layout or passive effects"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"useInsertionEffect")," cleanup and actual effect are executed both for every\ncomponent in a ",(0,r.kt)("inlineCode",{parentName:"li"},"bottom-to-up")," direction."))),(0,r.kt)("h4",{id:"3-layout-effects"},"3. Layout effects"),(0,r.kt)("p",null,"Layout effects ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCommitWork.js#L3099"},"are executed"),"\nin a sync way after render, so it will be blocking the browser main's thread\nfrom painting even if we wrote the new values to our new dom nodes."),(0,r.kt)("p",null,"During layout effects, React will do the work depending on the type of the\ncomponent:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"For FunctionComponents: ",(0,r.kt)("inlineCode",{parentName:"li"},"useLayoutEffect")),(0,r.kt)("li",{parentName:"ul"},"For ClassComponents: ",(0,r.kt)("inlineCode",{parentName:"li"},"componentDidMount"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"componentDidUpdate")),(0,r.kt)("li",{parentName:"ul"},"Attach ",(0,r.kt)("inlineCode",{parentName:"li"},"Ref")," when applied")),(0,r.kt)("h4",{id:"4-passive-effects"},"4. Passive effects"),(0,r.kt)("p",null,"Yes, passive effects will be invoked in a sync way if you rendered in a ",(0,r.kt)("inlineCode",{parentName:"p"},"SyncLane"),"."),(0,r.kt)("p",null,"This is not pretty common, and we've been told (same for ",(0,r.kt)("inlineCode",{parentName:"p"},"componentDidMount")," and\nupdate)."),(0,r.kt)("p",null,"If the render occurred in a non-",(0,r.kt)("inlineCode",{parentName:"p"},"SyncLane"),", then the passive effects\nwill be executed as scheduled previously in the ",(0,r.kt)("inlineCode",{parentName:"p"},"commitRootImpl"),"."))}p.isMDXComponent=!0}}]);