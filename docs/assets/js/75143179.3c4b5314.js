"use strict";(self.webpackChunkhowreactworks=self.webpackChunkhowreactworks||[]).push([[965],{629:(e,t,n)=>{n.d(t,{V:()=>p,_:()=>s});var r=n(3909),o=n(9901),a=n(1322);const i={plain:{color:"#393A34",backgroundColor:"#f6f8fa"},styles:[{types:["comment","prolog","doctype","cdata"],style:{color:"#999988",fontStyle:"italic"}},{types:["namespace"],style:{opacity:.7}},{types:["string","attr-value"],style:{color:"#e3116c"}},{types:["punctuation","operator"],style:{color:"#393A34"}},{types:["entity","url","symbol","number","boolean","variable","constant","property","regex","inserted"],style:{color:"#36acaa"}},{types:["atrule","keyword","attr-name","selector"],style:{color:"#00a4db"}},{types:["function","deleted","tag"],style:{color:"#d73a49"}},{types:["function-variable"],style:{color:"#6f42c1"}},{types:["tag","selector","keyword"],style:{color:"#00009f"}}]};let l=30;function s(e){let{stack:t=[],index:n=0,showCallbackQueue:r=!0}=e,a=n,i=t.length;if(!i)return null;let s,p,d=t.slice(0,Math.min(a,i-1)),k=d.filter((e=>e.isAsync)).map((e=>({fromAsync:!0,statement:e.asyncCallback}))),h=i+k.length;if(a>=h&&(a=(a+h)%h,d=t.slice(0,Math.min(a,i-1)),k=d.filter((e=>e.isAsync)).map((e=>({fromAsync:!0,statement:e.asyncCallback})))),a>=i){if(a>h)throw new Error("Index is too bug "+a);let e=[...t,...k];p=e[a],d=e.slice(0,a),s=e.slice(a+1),k=[]}else p=t[a],s=t.slice(a+1);let u=0;return o.createElement("div",{className:"el_container"},o.createElement("div",{className:"el_callstack"},d.map((e=>o.createElement(c,{key:e.statement,data:e}))),p&&o.createElement(c,{isCurrent:!0,data:p,key:p.statement}),s.map((e=>o.createElement(c,{data:e,key:e.statement})))),r&&o.createElement("div",{className:"el_callback_queue"},k.map((e=>o.createElement(c,{style:{bottom:u--*l+k.length*l},data:e,key:e.statement,className:"el_cb_queue_element"})))))}function c(e){let{data:t,className:n,style:r,isCurrent:l}=e,{statement:s,fromAsync:c}=t,p=n;return p||(p=`el_cs_element ${l?"el_cs_current":""} ${c?"el_cs_element_async":""}`),o.createElement("pre",{style:r,className:p},o.createElement(a.Z,{language:"ts",theme:i},c?"\ud83d\udd02":"",s))}function p(e){let[t,n]=o.useState(0),{delay:a=2e3,...i}=e;return o.useEffect((()=>{let e=setInterval((()=>{n((e=>e+1))}),a);return()=>clearInterval(e)}),[a]),o.createElement(s,(0,r.Z)({},i,{index:t}))}},2014:(e,t,n)=>{n.d(t,{N7:()=>i,aO:()=>o,bI:()=>l,fY:()=>r,hG:()=>a});const r=[{statement:"if (!isValidContainer(container)) {\n  throw new Error('createRoot(...): Target container is not a DOM element.');\n}"},{statement:"let isStrictMode = false;\nlet identifierPrefix = '';\n// ...other options\n\nif (options) {\n  if (options.unstable_strictMode === true) {\n    isStrictMode = true;\n  }\n  // ...\n}"},{statement:"const fiberRoot = createContainer(\n  container, // the host element\n  ConcurrentRoot, // the root type, or RootTag\n  null, // hydration callbacks\n  isStrictMode, // options?.unstable_strictMode || false\n  isConcurrentUpdatesByDefault,  // options?.unstable_concurrentUpdatesByDefault || false\n  identifierPrefix, // options?.identifierPrefix || ''\n  onRecoverableError, // options?.onRecoverableError || reportError || console.error\n  transitionCallbacks, // options?.unstable_transitionCallbacks || null\n);"},{statement:"// Mark container as root\ncontainer.__reactContainer$randomValue = fiberRoot.current;"},{statement:"// Injet ReactDom dispatcher\nDispatcher.current = ReactDOMClientDispatcher;"},{statement:"return new ReactDOMRoot(fiberRoot);"}],o=[{statement:"const current = container.current;"},{statement:"const lane = requestUpdateLane(current);"},{statement:"const update = createUpdate(lane);\nupdate.payload = {element};\nupdate.callback = callback;"},{statement:"const root = enqueueUpdate(current, update, lane);"},{statement:"scheduleUpdateOnFiber(root, current, lane);",isAsync:!0,asyncCallback:"processRootScheduleInMicrotask(root);"},{statement:"entangleTransitions(root, current, lane);"}],a=[{statement:"root.render(children);",isAsync:!0,asyncCallback:"processRootScheduleInMicrotask(root);"},{statement:"triggerImportantDataFetch();"},{statement:"RegisterServiceWorker();"}],i=[{statement:"if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n  throw new Error('Should not already be working.');\n}"},{statement:"const originalCallbackNode = root.callbackNode;\nconst didFlushPassiveEffects = flushPassiveEffects();\n\nif (didFlushPassiveEffects && root.callbackNode !== originalCallbackNode) {\n  return null;\n}"},{statement:"let lanes = getNextLanes(\n  root,\n  root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n);\nif (lanes === NoLanes) {\n  return null;\n}"},{statement:"const shouldTimeSlice =\n  !includesBlockingLane(root, lanes) &&\n  !includesExpiredLane(root, lanes) &&\n  (disableSchedulerTimeoutInWorkLoop || !didTimeout);"},{statement:"let exitStatus = shouldTimeSlice\n  ? renderRootConcurrent(root, lanes)\n  : renderRootSync(root, lanes);"},{statement:"if (renderWasSuccessfull) {\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  finishConcurrentRender(root, exitStatus, finishedWork, lanes);\n} else {\n  // manage errors and suspense\n}"},{statement:"ensureRootIsScheduled(root);\nreturn getContinuationForRoot(root, originalCallbackNode);"}],l=[{statement:"const prevExecutionContext = executionContext;\nexecutionContext |= RenderContext;\nconst prevDispatcher = pushDispatcher(root.containerInfo);"},{statement:"if (workInProgressRoot !== null || workInProgressRootRenderLanes !== lanes) {\n   // [...] some work\n   // highlight-next-line\n   prepareFreshStack(root, lanes);\n}"},{statement:"do {\n  try {\n    if (didSuspendDuringHydration) {\n      resetWIPStack();\n      workInProgressRootExitStatus = RootDidNotComplete;\n      break;\n    }\n    \n    // [...] Other branches to break when needed\n\n    // highlight-next-line\n    workLoopSync();\n    // Why a break here you wonder ? Hint: there is no break in the catch block\n    break;\n  } catch (e) {\n    // highlight-next-line\n    handleThrow(root, e);\n  }\n} while (true)"},{statement:"if (didSuspendInShell) {\n  root.shellSuspendCounter++;\n}\n\nexecutionContext = prevExecutionContext;\nworkInProgressRoot = null;\nworkInProgressRootRenderLanes = NoLanes;"},{statement:"finishQueueingConcurrentUpdates();\nreturn workInProgressRootExitStatus;"}]},2743:(e,t,n)=>{n.d(t,{Z:()=>o});var r=n(9901);function o(){return r.createElement("div",{style:{padding:8,textDecoration:"Window"}},r.createElement("i",null,r.createElement("p",null,"This section is not available yet. Please",r.createElement("a",{href:"https://github.com/incepter/how-react-works/issues/new",target:"_blank"}," fill an issue.")),r.createElement("p",null,"While waiting for the newsletter, you can get notified when new content drops by following",r.createElement("a",{href:"https://x.com/incepterr",target:"_blank"}," me on X."))))}},5574:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>k});var r=n(3909),o=(n(9901),n(7522)),a=n(2743),i=n(629),l=n(2014);const s={sidebar_position:5},c="How the work loop works",p={unversionedId:"react-dom/how.work_loop.works",id:"react-dom/how.work_loop.works",title:"How the work loop works",description:"Before we dive into the work loop, let's see how it starts for the first time.",source:"@site/docs/react-dom/5.how.work_loop.works.md",sourceDirName:"react-dom",slug:"/react-dom/how.work_loop.works",permalink:"/how-react-works/docs/react-dom/how.work_loop.works",draft:!1,editUrl:"https://github.com/incepter/how-react-works/edit/main/packages/howreactworks/docs/react-dom/5.how.work_loop.works.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"reactSidebar",previous:{title:"How root render schedule works",permalink:"/how-react-works/docs/react-dom/how.root_render_schedule.works"},next:{title:"How beginWork works",permalink:"/how-react-works/docs/react-dom/how.begin_work.works"}},d={},k=[{value:"How the concurrent work loop starts",id:"how-the-concurrent-work-loop-starts",level:2},{value:"<code>performConcurrentWorkOnRoot</code> signature",id:"performconcurrentworkonroot-signature",level:3},{value:"Implementation details",id:"implementation-details",level:3},{value:"TL;DR",id:"tldr",level:4},{value:"How <code>renderRootSync</code> works",id:"how-renderrootsync-works",level:2},{value:"TL;DR",id:"tldr-1",level:3},{value:"1. Mark render started",id:"1-mark-render-started",level:3},{value:"2. Push the context only dispatcher",id:"2-push-the-context-only-dispatcher",level:3},{value:"3. Prepare a fresh stack",id:"3-prepare-a-fresh-stack",level:3},{value:"4. Trigger the work loop",id:"4-trigger-the-work-loop",level:3},{value:"5. Handle thrown error",id:"5-handle-thrown-error",level:3},{value:"6. Restore execution context and dispatcher",id:"6-restore-execution-context-and-dispatcher",level:3},{value:"7. Finish the updates",id:"7-finish-the-updates",level:3},{value:"How <code>renderRootConcurrent</code> works",id:"how-renderrootconcurrent-works",level:2}],h={toc:k},u="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-the-work-loop-works"},"How the work loop works"),(0,o.kt)("p",null,"Before we dive into the work loop, let's see how it starts for the first time."),(0,o.kt)("h2",{id:"how-the-concurrent-work-loop-starts"},"How the concurrent work loop starts"),(0,o.kt)("p",null,"For the concurrent ",(0,o.kt)("inlineCode",{parentName:"p"},"root"),", the last thing we did is to schedule in\n",(0,o.kt)("inlineCode",{parentName:"p"},"scheduleTaskForRootDuringMicrotask")," a callback to ",(0,o.kt)("inlineCode",{parentName:"p"},"performConcurrentWorkOnRoot"),"."),(0,o.kt)("p",null,"Let's break into the concurrent work on root."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"root.callbackNode = scheduleCallback(\n  schedulerPriorityLevel,// NormalPriority for simple root.render\n  performConcurrentWorkOnRoot.bind(null, root),\n);\n")),(0,o.kt)("h3",{id:"performconcurrentworkonroot-signature"},(0,o.kt)("inlineCode",{parentName:"h3"},"performConcurrentWorkOnRoot")," signature"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L841"},(0,o.kt)("inlineCode",{parentName:"a"},"performConcurrentWorkOnRoot")),"\nis defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export function performConcurrentWorkOnRoot(\n  root: FiberRoot,\n  didTimeout: boolean,\n): RenderTaskFn | null { /* [Not Native Code] */ }\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"root")," property was bound when scheduling the callback, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"didTimeout"),"\nwill be passed when the scheduler will be executing ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/587ae49d71f218d34393291933d513d2975e22c3/packages/scheduler/src/forks/Scheduler.js#L234"},"this callback.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// inside scheduler, simplified\nconst didTimeout = didCallbackTimedOut();\nperformConcurrentWorkOnBoundRoot(didTimeout);\n\n// where\nconst performConcurrentWorkOnBoundRoot = performConcurrentWork.bind(null, root);\n")),(0,o.kt)("p",null,"This function will be rendering your components and performing the whole logic,\nso basically it will be insanely long, but we will move some parts from it\nto their own sections (like ",(0,o.kt)("inlineCode",{parentName:"p"},"WorkTags"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"effects")," types and their implementation\ndetails, and obviously",(0,o.kt)("inlineCode",{parentName:"p"},"hooks")," too )."),(0,o.kt)("h3",{id:"implementation-details"},"Implementation details"),(0,o.kt)("h4",{id:"tldr"},"TL;DR"),(0,o.kt)(i._,{stack:l.N7,showCallbackQueue:!1,index:4,mdxType:"EventLoopComponent"}),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Guard against calls to this function when already rendering or committing"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n  throw new Error('Should not already be working.');\n}\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Flush passive effects"),(0,o.kt)("p",{parentName:"li"},"Effects will be fully discussed in their own section. It will be linked here\nonce ready."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\n\n// this referencement here because flushPassiveEffects might schedule updates\nconst originalCallbackNode = root.callbackNode;\nconst didFlushPassiveEffects = flushPassiveEffects();\n\nif (didFlushPassiveEffects && root.callbackNode !== originalCallbackNode) {\n  return null;\n}\n")),(0,o.kt)("p",{parentName:"li"},"When passive effects are flushed and something did cancel the current\nscheduled callback, this function will stop execution and return ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),",\nbecause the other schedule would trigger its own work."),(0,o.kt)("p",{parentName:"li"},"From the ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render()")," perspective, we have no effects until now, so we\nwill continue the execution. That's another reason to skip this section\nfor now.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Compute again the ",(0,o.kt)("inlineCode",{parentName:"p"},"nextLanes")),(0,o.kt)("p",{parentName:"li"},"This is a leftover that should be fixed (until now), the next lanes\nare computed here again (we computed them first above in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"scheduleTaskForRootDuringMicrotask")," function.)"),(0,o.kt)("p",{parentName:"li"},"And obviously, if there are ",(0,o.kt)("inlineCode",{parentName:"p"},"NoLanes")," (no work to do), then ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," is\nreturned.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Determine if it should ",(0,o.kt)("inlineCode",{parentName:"p"},"time slice")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const shouldTimeSlice =\n  !includesBlockingLane(root, lanes) &&\n  !includesExpiredLane(root, lanes) &&\n  (disableSchedulerTimeoutInWorkLoop || !didTimeout);\n")),(0,o.kt)("p",{parentName:"li"},"To ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L888"},"use time slicing"),"\n, the root should not include ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L475"},(0,o.kt)("inlineCode",{parentName:"a"},"BlockingLanes")),"\nor ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb/packages/react-reconciler/src/ReactFiberLane.js#L491"},(0,o.kt)("inlineCode",{parentName:"a"},"ExpiredLanes"),".")),(0,o.kt)("p",{parentName:"li"},"Blocking lanes are (per the previous link): ",(0,o.kt)("inlineCode",{parentName:"p"},"SyncDefaultLanes"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"InputContinuousHydrationLane"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"InputContinuousLane"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"DefaultHydrationLane"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"DefaultLane"),"."),(0,o.kt)("p",{parentName:"li"},"Yes, from ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render()")," without transition we are in ",(0,o.kt)("inlineCode",{parentName:"p"},"DefaultLane")," so this\nrender will be considered without time slicing, and thus a ",(0,o.kt)("inlineCode",{parentName:"p"},"Sync")," one.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Call render function based on time slicing"),(0,o.kt)("p",{parentName:"li"},"Depending on whether it should time slice, it will call ",(0,o.kt)("inlineCode",{parentName:"p"},"renderRootConcurrent"),"\nor else it will fall back to ",(0,o.kt)("inlineCode",{parentName:"p"},"renderRootSync"),"."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"let exitStatus = shouldTimeSlice\n  ? renderRootConcurrent(root, lanes)\n  : renderRootSync(root, lanes);\n")),(0,o.kt)("p",{parentName:"li"},"The whole rendering logic should be done after calling the previous functions."),(0,o.kt)("p",{parentName:"li"},"We will see them in details in a few, but keep in mind that after the whole\nrender ends, we will perform the following steps too")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Finish rendering and perform logic based on ",(0,o.kt)("inlineCode",{parentName:"p"},"exitStatus")),(0,o.kt)("p",{parentName:"li"},"The possible exitStatus values are ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L302"},"listed here."),"\nReact will then either ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L903"},"mark the root as suspended"),"\nif the render did not complete, or else:"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Verify that the render is consistent ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L915"},"with external stores."),"\nIf not, a sync render ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L919"},"will be performed")),(0,o.kt)("p",{parentName:"li"},"Then the ",(0,o.kt)("inlineCode",{parentName:"p"},"while(true)")," loop ",(0,o.kt)("inlineCode",{parentName:"p"},"continue")," until a good ",(0,o.kt)("inlineCode",{parentName:"p"},"exitStatus")," is\nobtained.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In case of ",(0,o.kt)("inlineCode",{parentName:"p"},"RootErrored")," errors, React will attempt to\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L936"},"recover from them if possible."),"\nIt will attempt to render again ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L997"},"using ",(0,o.kt)("inlineCode",{parentName:"a"},"renderRootSync")),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"exitStatus")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"RootFatalErrored"),": TBD, this highlights probably\na bug in React that prevented it from rendering.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Or else, then the tree is consistent and the work is considered as finished"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\n\n// React when rendering (we will see in the next section) will store\n// the render work output in a property called alternate in each fiber\n// we will see them in details in a few\nconst finishedWork: Fiber = root.current.alternate;\n")),(0,o.kt)("p",{parentName:"li"},"This variable is then affected to the finishedWork property of the ",(0,o.kt)("inlineCode",{parentName:"p"},"root"),"\nand then ",(0,o.kt)("inlineCode",{parentName:"p"},"finishConcurrentRender")," is called."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"root.finishedWork = finishedWork;\nroot.finishedLanes = lanes;\nfinishConcurrentRender(root, exitStatus, finishedWork, lanes);\n")),(0,o.kt)("p",{parentName:"li"},"// todo: back to this once renderRoot is done")))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Ensure root is scheduled"),(0,o.kt)("p",{parentName:"li"},"We already saw this in the how ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render()")," works section which will\nschedule again a micro task to attempt to render the root again, but mostly\nit won't find any work to do (it will know by only looking at the ",(0,o.kt)("inlineCode",{parentName:"p"},"nextLanes"),").")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Return a continuation for the root"),(0,o.kt)(a.Z,{mdxType:"TBD"}))),(0,o.kt)("h2",{id:"how-renderrootsync-works"},"How ",(0,o.kt)("inlineCode",{parentName:"h2"},"renderRootSync")," works"),(0,o.kt)("p",null,"So, we are finally there! The function that renders our components."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function renderRootSync(root: FiberRoot, lanes: Lanes) {\n  // [Not Native Code]\n}\n")),(0,o.kt)("h3",{id:"tldr-1"},"TL;DR"),(0,o.kt)(i.V,{stack:l.bI,showCallbackQueue:!1,mdxType:"AnimatedEventLoop"}),(0,o.kt)("h3",{id:"1-mark-render-started"},"1. Mark render started"),(0,o.kt)("p",null,"There is a global variable that WorkLoop module uses: ",(0,o.kt)("inlineCode",{parentName:"p"},"executionContext"),", which\nis a number used the same way Lanes are used. The possible values ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L297"},"are:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export const NoContext = /*             */ 0b000;\nconst BatchedContext = /*               */ 0b001;\nexport const RenderContext = /*         */ 0b010;\nexport const CommitContext = /*         */ 0b100;\n")),(0,o.kt)("p",null,"When the ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," starts, the ",(0,o.kt)("inlineCode",{parentName:"p"},"executionContext")," is modified ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1838"},"as follows:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const prevExecutionContext = executionContext;\nexecutionContext |= RenderContext;\n\n// later, after the render finishes:\nexecutionContext = prevExecutionContext;\n")),(0,o.kt)("p",null,"This variable is so important to React, it can know what kind of work it is\nperforming and guard against mis-usages."),(0,o.kt)("h3",{id:"2-push-the-context-only-dispatcher"},"2. Push the context only dispatcher"),(0,o.kt)("p",null,"The React dispatcher is an object having several properties (such as hooks)\nthat is used by React to propagate behavior like in ",(0,o.kt)("inlineCode",{parentName:"p"},"dependency injection"),"\nfashioned way."),(0,o.kt)("p",null,"At this point when the work loop is about to start, this is a transitory phase\nand coming from the ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render")," path, a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/ddff504695f33c19e8c0792bff82bd8f8b8f7c05/packages/react-reconciler/src/ReactFiberHooks.js#L3296"},(0,o.kt)("inlineCode",{parentName:"a"},"ContextOnlyDispatcher")),"\nis used which will allow only ",(0,o.kt)("inlineCode",{parentName:"p"},"readContext")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"use"),"."),(0,o.kt)("p",null,"The same is done to the upcoming ",(0,o.kt)("inlineCode",{parentName:"p"},"cache")," feature of React, it will have its own\ndispatcher."),(0,o.kt)("p",null,"The dispatchers will be more detailed in their own section."),(0,o.kt)("h3",{id:"3-prepare-a-fresh-stack"},"3. Prepare a fresh stack"),(0,o.kt)("p",null,"Next, ",(0,o.kt)("inlineCode",{parentName:"p"},"renderRoot")," will have to check the currently processed root and its lanes\nfrom the global variables against the root that it received from arguments\nwhile scheduling."),(0,o.kt)("p",null,"You can ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1503"},"see it here.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (workInProgressRoot !== null || workInProgressRootRenderLanes !== lanes) {\n   // some work\n   prepareFreshStack(root, lanes);\n}\n")),(0,o.kt)("p",null,"Preparing a fresh stack is the process of removing and emptying any information\nthat was attached during a previous work or render."),(0,o.kt)("p",null,"Let's dive into its steps:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Set the following ",(0,o.kt)("inlineCode",{parentName:"p"},"root")," properties to ",(0,o.kt)("inlineCode",{parentName:"p"},"null")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"finishedWork")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"finishedLanes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"timeoutHandle"),", will also cancel any existing timeout (to commit)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cancelPendingCommit")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Reset the work in progress stack"),(0,o.kt)("p",{parentName:"li"},"React will do nothing here when coming from ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render()"),", but it will\nreset several Fiber modules and their global variables (their internal state)\nand interrupt any ongoing work. This is normal since we are starting a render\ncycle and things need to ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1478"},"be clean."),"\nThis process may be the most important and critical to be done correctly.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Reset the work loop internal state variables"),(0,o.kt)("p",{parentName:"li"},"This involves setting the following variable to their default values:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRoot")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"root")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgress")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"createWorkInProgress(root.current, null)"),": Pay attention\nto this particular variable involving the creation of a second fiber."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"renderLanes")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"lanes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootRenderLanes")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"lanes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressSuspendedReason")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"NotSuspended")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressThrownValue")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"null")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootDidAttachPingListener")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"false")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootExitStatus")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"RootInProgress")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootFatalError")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"null")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootSkippedLanes")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"NoLanes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootInterleavedUpdatedLanes")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"NoLanes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootRenderPhaseUpdatedLanes")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"NoLanes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootPingedLanes")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"NoLanes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootConcurrentErrors")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"null")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"workInProgressRootRecoverableErrors")," = ",(0,o.kt)("inlineCode",{parentName:"li"},"null"))),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"createWorkInProgress")," is very important, so we should ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/eaa696876ee40bb048727aefe995be1bbb7384a8/packages/react-reconciler/src/ReactFiber.js#L269"},"visit it too."),"\nIt is responsible for creating a second fiber (the ",(0,o.kt)("inlineCode",{parentName:"p"},"alternate"),") that mirrors\nout FiberNode (",(0,o.kt)("inlineCode",{parentName:"p"},"root.current"),"). We will be seeing it again during the work."),(0,o.kt)("p",{parentName:"li"},"The alternate is used by react as a ",(0,o.kt)("inlineCode",{parentName:"p"},"DRAFT")," or a ",(0,o.kt)("inlineCode",{parentName:"p"},"SNAPSHOT")," of the ongoing\nwork (or render), that once finished will be committed to be the main fiber\nand then the previous main fiber is released."),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"createWorkInProgress")," will be revisited again in the next section.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Finish queuing the concurrent updates"),(0,o.kt)("p",{parentName:"li"},"Do you remember the ",(0,o.kt)("inlineCode",{parentName:"p"},"concurrentQueues")," variable from how ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render()")," works?\nWell, ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render()")," did not do anything to our ",(0,o.kt)("inlineCode",{parentName:"p"},"root"),", but it just\nscheduled its render via microtask queue, and at the same time, it did leave\nthe render ",(0,o.kt)("inlineCode",{parentName:"p"},"children")," as an update stored in a global variable; like this:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"concurrentQueues[id++] = fiber;\nconcurrentQueues[id++] = sharedQueue;\nconcurrentQueues[id++] = update;\nconcurrentQueues[id++] = lane;\n")),(0,o.kt)("p",{parentName:"li"},"Now is time to ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/f101c2d0d3a6cb5a788a3d91faef48462e45f515/packages/react-reconciler/src/ReactFiberConcurrentUpdates.js#L50"},"process this array"),"\nwith the following steps:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Loop to the end of this array and each time reference the variables using\nthe same order we added them, then remove them from the array by setting\nthem to ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"while (i < end) {\n  const fiber: Fiber = concurrentQueues[i];\n  concurrentQueues[i++] = null;\n  const queue: ConcurrentQueue = concurrentQueues[i];\n  concurrentQueues[i++] = null;\n  const update: ConcurrentUpdate = concurrentQueues[i];\n  concurrentQueues[i++] = null;\n  const lane: Lane = concurrentQueues[i];\n  concurrentQueues[i++] = null;\n\n  // at this point the update is attached to fiber's queue, it wasn't before\n  if (queue !== null && update !== null) {\n    const pending = queue.pending;\n    if (pending === null) {\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n    queue.pending = update;\n  }\n  if (lane !== NoLane) {\n    // this will make use of the fiber, we've already seen it too in\n    // the root.render section.\n    // it will merge these lanes starting from this fiber to its root\n    // (including alternate if present)\n    // highlight-next-line\n    markUpdateLaneFromFiberToRoot(fiber, update, lane);\n  }\n}\n")))))),(0,o.kt)("h3",{id:"4-trigger-the-work-loop"},"4. Trigger the work loop"),(0,o.kt)("p",null,"Finally, for real this time (almost)! we are there!"),(0,o.kt)("p",null,"React will then start a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1877"},(0,o.kt)("inlineCode",{parentName:"a"},"do while(true)")),"\nloop where it will call ",(0,o.kt)("inlineCode",{parentName:"p"},"workLoopSync()")," (the work loop \ud83d\ude44). Let's take a look\nat the simplified loop:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\n\ndo {\n  try {\n    if (didSuspendDuringHydration) {\n      resetWIPStack();\n      workInProgressRootExitStatus = RootDidNotComplete;\n      break;\n    }\n\n     // highlight-next-line\n     workLoopSync();\n     // Why a break here you wonder ? Hint: there is no break in the catch block\n     break;\n  } catch (e) {\n     // highlight-next-line\n     handleThrow(root, e);\n  }\n} while (true)\n\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1971"},(0,o.kt)("inlineCode",{parentName:"a"},"workLoopSync")),"\nis defined as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function workLoopSync() {\n  // read well the following comment from React codebase\n  // highlight-next-line\n  // Perform work without checking if we need to yield between fiber.\n  while (workInProgress !== null) {\n    // highlight-next-line\n    performUnitOfWork(workInProgress);\n  }\n}\n\n\nfunction workLoopConcurrent() {\n  // read well the following comment from React codebase\n  // highlight-next-line\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    // highlight-next-line\n    performUnitOfWork(workInProgress);\n  }\n}\n")),(0,o.kt)("p",null,"Here is a simplified version of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L2238"},"how ",(0,o.kt)("inlineCode",{parentName:"a"},"performUnitOfWork")," works:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\n// the unitOfWork Fiber passed here is the global workInProgress variable\n// which was initialized by the fiberRoot.current.alternate\n\n// so basically the workInProgress initially = the alternate\n// which means that the 'current' tree is the workInProfress.alternate\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  const current = unitOfWork.alternate;\n\n  // highlight-next-line\n  const next = beginWork(current, unitOfWork, renderLanes);\n  \n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    // highlight-next-line\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n}\n\n")),(0,o.kt)("p",null,"So begin work will render the fiber and return the next one."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"beginWork")," is detailed in the next section, but it is\nimportant to note at this stage that it receives both the current unit of work\nand its alternate. it is like: render into the ",(0,o.kt)("inlineCode",{parentName:"p"},"alternate")," the main ",(0,o.kt)("inlineCode",{parentName:"p"},"fiber"),"\nusing the ",(0,o.kt)("inlineCode",{parentName:"p"},"renderLanes")," and return the ",(0,o.kt)("inlineCode",{parentName:"p"},"next")," unit of work."),(0,o.kt)("p",null,"Like mentioned earlier, the ",(0,o.kt)("inlineCode",{parentName:"p"},"alternate")," refers to the ",(0,o.kt)("inlineCode",{parentName:"p"},"workInProgerss")," while\nthe original ",(0,o.kt)("inlineCode",{parentName:"p"},"fiber")," will be the ",(0,o.kt)("inlineCode",{parentName:"p"},"current")," tree."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"This is the actual sync work loop: ",(0,o.kt)("strong",{parentName:"p"},"Keep performing work until there is\nnothing left to do."))),(0,o.kt)("p",null,"As you may know already, React will construct a fiber tree from the received\n",(0,o.kt)("inlineCode",{parentName:"p"},"children")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render")," and will keep working until it reaches the end.\nHow they are linked and how the next fiber is chosen will be detailed in a\nseparate section, this one is for the loop."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("inlineCode",{parentName:"p"},"beginWork")," will end up calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"reconcileChildren")," function whose role to\nfind child to work on next."),(0,o.kt)("p",{parentName:"admonition"},"So, React will go down in your tree until it reaches the very bottom in\nsequential way: It will perform work on each component and its first\nchild recursively until the bottom."),(0,o.kt)("p",{parentName:"admonition"},"When the next child is ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),", then React will call ",(0,o.kt)("inlineCode",{parentName:"p"},"completeWork")," on the work\nthat has no children, and in this process, React will either work on its\nsibling (the component at the same level on the tree) or its parent's sibling\n(their uncle)."),(0,o.kt)("p",{parentName:"admonition"},"This process is detailed in the ",(0,o.kt)("inlineCode",{parentName:"p"},"how completeWork works")," section.")),(0,o.kt)("h3",{id:"5-handle-thrown-error"},"5. Handle thrown error"),(0,o.kt)("p",null,"If the render phase ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1921"},"did throw an error"),"\n, it is a sign that React will either show Suspense fallback, show an error\nboundary or a blank page."),(0,o.kt)("p",null,"This process is complex and long and manages many cases, we will dedicate\na whole section for it."),(0,o.kt)(a.Z,{mdxType:"TBD"}),(0,o.kt)("h3",{id:"6-restore-execution-context-and-dispatcher"},"6. Restore execution context and dispatcher"),(0,o.kt)("p",null,"So by here the render is completed, React will then proceed to reset some\nvariables and perform some checks:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// workloop code\n\nresetContextDependencies();\nrestoreExecutionContextAndDispatcher();\nthrowAsDefensiveIfThereIsStillSomeWorkToDo();\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Reset context dependencies"),(0,o.kt)("p",{parentName:"li"},"This will reset the context's module internal state (module variables)\nbecause render ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/540bab085d571789f4562565eebfd0db9f36345c/packages/react-reconciler/src/ReactFiberNewContext.js#L80"},"did complete"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Restore execution context"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// we've already seen it above\nexecutionContext = prevExecutionContext;\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Throw if there is still work to do"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"if (workInProgress !== null) {\n  throw new Error(\n    'Cannot commit an incomplete root. This error is likely caused by a ' +\n      'bug in React. Please file an issue.',\n  );\n}\n")))),(0,o.kt)("h3",{id:"7-finish-the-updates"},"7. Finish the updates"),(0,o.kt)("p",null,"This is the same process we've seen when preparing a fresh stack, React will\nperform a second pass on the ",(0,o.kt)("inlineCode",{parentName:"p"},"concurrentQueues")," in case another update is\nscheduled when rendering."),(0,o.kt)("p",null,"In a simple case, nothing will be done."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"finishQueueingConcurrentUpdates();\n")),(0,o.kt)("h2",{id:"how-renderrootconcurrent-works"},"How ",(0,o.kt)("inlineCode",{parentName:"h2"},"renderRootConcurrent")," works"),(0,o.kt)("p",null,"There are noticeable differences from the ",(0,o.kt)("inlineCode",{parentName:"p"},"sync")," render, to pass via this\npath from ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render()"),", you should satisfy the ",(0,o.kt)("inlineCode",{parentName:"p"},"shouldTimeSlice")," condition."),(0,o.kt)("p",null,"To do so, the simplest way (if not the only way) is to wrap ",(0,o.kt)("inlineCode",{parentName:"p"},"root.render()"),"\nwith ",(0,o.kt)("inlineCode",{parentName:"p"},"startTransition"),"."),(0,o.kt)("p",null,"In this case, ",(0,o.kt)("inlineCode",{parentName:"p"},"renderRootConcurrent")," is called with the same signature. Let's\ndive ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/dd480ef923930c8906a02664b01bcdea50707b5d/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1978"},"into it:")),(0,o.kt)("p",null,"todo: back to this after begin work and leaf sections"))}m.isMDXComponent=!0}}]);