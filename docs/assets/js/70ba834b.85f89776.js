"use strict";(self.webpackChunkhowreactworks=self.webpackChunkhowreactworks||[]).push([[422],{7522:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var o=t(9901);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=o.createContext({}),c=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(s.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},k=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(t),k=r,h=m["".concat(s,".").concat(k)]||m[k]||d[k]||i;return t?o.createElement(h,a(a({ref:n},p),{},{components:t})):o.createElement(h,a({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=k;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[m]="string"==typeof e?e:r,a[1]=l;for(var c=2;c<i;c++)a[c]=t[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}k.displayName="MDXCreateElement"},2743:(e,n,t)=>{t.d(n,{Z:()=>r});var o=t(9901);function r(){return o.createElement("div",{style:{padding:8,textDecoration:"Window"}},o.createElement("i",null,o.createElement("p",null,"This section is not available yet. Please",o.createElement("a",{href:"https://github.com/incepter/how-react-works/issues/new",target:"_blank"}," fill an issue.")),o.createElement("p",null,"While waiting for the newsletter, you can get notified when new content drops by following",o.createElement("a",{href:"https://x.com/incepterr",target:"_blank"}," me on X."))))}},3589:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>k,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var o=t(3909),r=(t(9901),t(7522)),i=t(2743);const a={sidebar_position:11},l="How completeWork works",s={unversionedId:"react-dom/how.complete_work.works",id:"react-dom/how.complete_work.works",title:"How completeWork works",description:"A few sections back, we rendered our application using React. This process",source:"@site/docs/react-dom/11.how.complete_work.works.md",sourceDirName:"react-dom",slug:"/react-dom/how.complete_work.works",permalink:"/how-react-works/docs/react-dom/how.complete_work.works",draft:!1,editUrl:"https://github.com/incepter/how-react-works/edit/main/packages/howreactworks/docs/react-dom/11.how.complete_work.works.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"reactSidebar",previous:{title:"How hooks work",permalink:"/how-react-works/docs/react-dom/how.hooks.work"},next:{title:"How Commit works",permalink:"/how-react-works/docs/react-dom/how.commit.works"}},c={},p=[{value:"Signature",id:"signature",level:2},{value:"Implementation",id:"implementation",level:2},{value:"How <code>completeWork</code> works",id:"how-completework-works-1",level:2},{value:"Signature",id:"signature-1",level:3},{value:"How completing <code>FunctionComponent</code> works",id:"how-completing-functioncomponent-works",level:3},{value:"How completing <code>ClassComponent</code> works",id:"how-completing-classcomponent-works",level:3},{value:"How completing <code>HostRoot</code> works",id:"how-completing-hostroot-works",level:3},{value:"How other tags work",id:"how-other-tags-work",level:3},{value:"Recap",id:"recap",level:2}],m={toc:p},d="wrapper";function k(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-completework-works"},"How completeWork works"),(0,r.kt)("p",null,"A few sections back, we rendered our application using React. This process\nwas very similar to the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\nfunction workLoopSync() {\n  // Perform work without checking if we need to yield between fiber.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  const current = unitOfWork.alternate;\n\n  // highlight-next-line\n  const next = beginWork(current, unitOfWork, renderLanes);\n  \n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    // highlight-next-line\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n}\n\n")),(0,r.kt)("p",null,"Like we mentioned in an earlier section, React work loop will render a single\npath from the ",(0,r.kt)("inlineCode",{parentName:"p"},"fiberRoot")," passing direct first child by direct first child until\nit reaches the very bottom."),(0,r.kt)("p",null,"In this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"beginWork")," will return a ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," fiber, which means there is no\nmore work to do in the current tree."),(0,r.kt)("p",null,"That's the role of the ",(0,r.kt)("inlineCode",{parentName:"p"},"completeUnitOfWork")," function: it will infer the next\ncomponent to render."),(0,r.kt)("p",null,"We will see in details how the next fiber is chosen."),(0,r.kt)("h2",{id:"signature"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function completeUnitOfWork(unitOfWork: Fiber): void {\n  \n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"completeUnitOfWork")," is called with the ",(0,r.kt)("inlineCode",{parentName:"p"},"workInProgress")," variable that refers\nto the completed work of a component."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"The goal of this function is to decide the next fiber to work on."),(0,r.kt)("p",null,"Here is a simplified version of it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\nlet completeWork = unitOfWork;\n\ndo {\n  const current = completeWork.alternate;\n  const returnFiber = completedWork.return;\n  // complete work is a huge function that contains the real implementation\n  // we will see it in a few.\n  // highlight-next-line\n  const next = completeWork(current, completeWork, renderLanes);\n  \n  // complete work decided that there is still some work to do\n  if (next !== null) {\n    // highlight-next-line\n    workInProgress = next;\n    return;\n  }\n\n  // if there is no next, take the sibling\n  const siblingFiber = completeWork.sibling;\n  if (siblingFiber !== null) {\n    // highlight-next-line\n    workInProgress = siblingFiber;\n    return;\n  }\n  \n  // otherwise, take the returnFiber of the completeWork\n  completedWork = returnFiber;\n  // highlight-next-line\n  workInProgress = completedWork;\n} while (completeWork !== null);\n//...\n")),(0,r.kt)("p",null,"So ",(0,r.kt)("inlineCode",{parentName:"p"},"completeUnitOfWork")," will keep climbing back the tree while passing by\nthe siblings and so on."),(0,r.kt)("p",null,"On important thing to mention is that while passing to a ",(0,r.kt)("inlineCode",{parentName:"p"},"sibling"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"performUnitOfWork")," will pass through all its children until it reaches the\nbottom again, then climb back using ",(0,r.kt)("inlineCode",{parentName:"p"},"completeUnitOfWork"),"."),(0,r.kt)("p",null,"But, ",(0,r.kt)("inlineCode",{parentName:"p"},"completeUnitOfWork")," doesn't do all the work, it calls a huge function\nof around 1000 lines of code (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCompleteWork.js#L927"},(0,r.kt)("inlineCode",{parentName:"a"},"completeWork")),")\nthat we will see right now."),(0,r.kt)("p",null,"It is important to check this function for two reasons: The first is that it is\ncalled from within ",(0,r.kt)("inlineCode",{parentName:"p"},"completeUnitOfWork")," to decide the next fiber, and as fallback\nwhen null is returned, it will look up on the sibling and parent."),(0,r.kt)("h2",{id:"how-completework-works-1"},"How ",(0,r.kt)("inlineCode",{parentName:"h2"},"completeWork")," works"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"completeWork")," is a huge function with a big ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCompleteWork.js#L938"},(0,r.kt)("inlineCode",{parentName:"a"},"switch statement")),"."),(0,r.kt)("h3",{id:"signature-1"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler: \n    // .... other tags\n    {\n      \n    }\n  }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"completeWork")," will perform the work based on the tag of the finished work."),(0,r.kt)("h3",{id:"how-completing-functioncomponent-works"},"How completing ",(0,r.kt)("inlineCode",{parentName:"h3"},"FunctionComponent")," works"),(0,r.kt)("p",null,"Function component is treated like any of these: ",(0,r.kt)("inlineCode",{parentName:"p"},"IndeterminateComponent"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"LazyComponent"),",",(0,r.kt)("inlineCode",{parentName:"p"},"SimpleMemoComponent"),",",(0,r.kt)("inlineCode",{parentName:"p"},"FunctionComponent"),",",(0,r.kt)("inlineCode",{parentName:"p"},"ForwardRef"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"Fragment"),",",(0,r.kt)("inlineCode",{parentName:"p"},"Mode"),",",(0,r.kt)("inlineCode",{parentName:"p"},"Profiler"),",",(0,r.kt)("inlineCode",{parentName:"p"},"ContextConsumer"),",",(0,r.kt)("inlineCode",{parentName:"p"},"MemoComponent"),"."),(0,r.kt)("p",null,"And it does the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"switch (workInProgress.tag) {\n  case IndeterminateComponent:\n  case LazyComponent:\n  case SimpleMemoComponent:\n  case FunctionComponent:\n  case ForwardRef:\n  case Fragment:\n  case Mode:\n  case Profiler:\n  case ContextConsumer:\n  case MemoComponent:\n    bubbleProperties(workInProgress);\n    return null;\n  }\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCompleteWork.js#L715"},(0,r.kt)("inlineCode",{parentName:"a"},"bubbleProperties")),"\nis invoked on completed work, and it serves to merge the flags of the children\ninside their parent (the complete work):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\nfunction bubbleProperties(completedWork: Fiber) {\n  let subtreeFlags = NoFlags;\n  let newChildLanes = NoLanes;\n  let child = completedWork.child;\n  \n  while (child !== null) {\n    newChildLanes = mergeLanes(\n      newChildLanes,\n      mergeLanes(child.lanes, child.childLanes),\n    );\n\n    subtreeFlags |= child.subtreeFlags;\n    subtreeFlags |= child.flags;\n\n    child.return = completedWork;\n    child = child.sibling;\n  }\n\n  completedWork.subtreeFlags |= subtreeFlags;\n  completedWork.childLanes = newChildLanes;\n}\n")),(0,r.kt)("h3",{id:"how-completing-classcomponent-works"},"How completing ",(0,r.kt)("inlineCode",{parentName:"h3"},"ClassComponent")," works"),(0,r.kt)("p",null,"Finishing the work for ",(0,r.kt)("inlineCode",{parentName:"p"},"ClassComponent"),"s is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"FunctionComponent"),"\nand the others since it will bubble the properties as well (this will be done\nin almost all cases)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"switch (workInProgress.tag) {\n  // ...\n  case ClassComponent: {\n    const Component = workInProgress.type;\n    if (isLegacyContextProvider(Component)) {\n      popLegacyContext(workInProgress);\n    }\n    // same as FunctionComponent\n    bubbleProperties(workInProgress);\n    return null;\n  }\n  // ...\n}\n")),(0,r.kt)("p",null,"ClassComponents have this special branching where they can be context providers\nat the same time using the legacy ",(0,r.kt)("inlineCode",{parentName:"p"},"getChildContext()")," API."),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"getChildContext()")," is marked as legacy and may not be active or bundled anymore.\nAvoid this API.")),(0,r.kt)("h3",{id:"how-completing-hostroot-works"},"How completing ",(0,r.kt)("inlineCode",{parentName:"h3"},"HostRoot")," works"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/7f6201889e8e628eeb53e05d8850ddffa3c2e74a/packages/react-reconciler/src/ReactFiberCompleteWork.js#L959"},"Switch case")),(0,r.kt)(i.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-other-tags-work"},"How other tags work"),(0,r.kt)(i.Z,{mdxType:"TBD"}),(0,r.kt)("h2",{id:"recap"},"Recap"),(0,r.kt)("p",null,"When all work is completed, and we rendered until reaching the very bottom of\neach node of our tree, the ",(0,r.kt)("inlineCode",{parentName:"p"},"performConcurrentWorkOnRoot")," will proceed then to\ncompleting the render and committing the ",(0,r.kt)("inlineCode",{parentName:"p"},"root"),"."),(0,r.kt)("p",null,"Please take a look at the following code, we've already seen it, but it is\nbetter that you refresh your memory to prepare for the next section."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified to only include relevant things\nfunction performConcurrentWorkOnRoot(\n  root: FiberRoot,\n  didTimeout: boolean,\n): RenderTaskFn | null {\n  // previous code\n  \n  const exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes) \n    : renderRootSync(root, lanes);\n  \n  if (exitStatus !== RootInProgress) {\n    do {\n      if (exitStatus === RootDidNotComplete) {\n        markRootSuspended(root, lanes);\n      } else {\n        const finishedWork: Fiber = root.current.alternate;\n\n        if (\n          renderWasConcurrent &&\n          !isRenderConsistentWithExternalStores(finishedWork)\n        ) {\n          exitStatus = renderRootSync(root, lanes);\n          continue;\n        }\n        if (exitStatus === RootErrored) {\n          // ...\n        }\n        if (exitStatus === RootFatalErrored) {\n          // ...\n          throw fatalError;\n        }\n\n        // highlight-next-line\n        root.finishedWork = finishedWork;\n        // highlight-next-line\n        root.finishedLanes = lanes;\n        // highlight-next-line\n        finishConcurrentRender(root, exitStatus, finishedWork, lanes);\n      }\n      break;\n    } while (true);\n  }\n}\n")),(0,r.kt)("p",null,"The whole workLoop occurred inside ",(0,r.kt)("inlineCode",{parentName:"p"},"renderRootSync")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"renderRootConcurrent"),"\ndepending on your render lanes."),(0,r.kt)("p",null,"So after all work is done, the following code is what's important at this stage,\nspecifically the ",(0,r.kt)("inlineCode",{parentName:"p"},"finishConcurrentRender"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"root.finishedWork = finishedWork;\nroot.finishedLanes = lanes;\n// highlight-next-line\nfinishConcurrentRender(root, exitStatus, finishedWork, lanes);\n")),(0,r.kt)("p",null,"Let's dive into finishing the render and the commit phase in the next section."))}k.isMDXComponent=!0}}]);