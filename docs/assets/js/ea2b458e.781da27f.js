"use strict";(self.webpackChunkhowreactworks=self.webpackChunkhowreactworks||[]).push([[794],{7522:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>p});var o=n(9901);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},k="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),k=u(n),d=r,p=k["".concat(l,".").concat(d)]||k[d]||c[d]||a;return n?o.createElement(p,s(s({ref:t},h),{},{components:n})):o.createElement(p,s({ref:t},h))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[k]="string"==typeof e?e:r,s[1]=i;for(var u=2;u<a;u++)s[u]=n[u];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2743:(e,t,n)=>{n.d(t,{Z:()=>r});var o=n(9901);function r(){return o.createElement("div",{style:{padding:8,textDecoration:"Window"}},o.createElement("i",null,o.createElement("p",null,"This section is not available yet. Please",o.createElement("a",{href:"https://github.com/incepter/how-react-works/issues/new",target:"_blank"}," fill an issue.")),o.createElement("p",null,"While waiting for the newsletter, you can get notified when new content drops by following",o.createElement("a",{href:"https://x.com/incepterr",target:"_blank"}," me on X."))))}},2765:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var o=n(3909),r=(n(9901),n(7522)),a=n(2743);const s={sidebar_position:10},i="How hooks work",l={unversionedId:"react-dom/how.hooks.work",id:"react-dom/how.hooks.work",title:"How hooks work",description:"Introduction",source:"@site/docs/react-dom/10.how.hooks.work.md",sourceDirName:"react-dom",slug:"/react-dom/how.hooks.work",permalink:"/how-react-works/docs/react-dom/how.hooks.work",draft:!1,editUrl:"https://github.com/incepter/how-react-works/edit/main/packages/howreactworks/docs/react-dom/10.how.hooks.work.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"reactSidebar",previous:{title:"How Fibers creation works \u23f8\ufe0f",permalink:"/how-react-works/docs/react-dom/how.fiber_creation.works"},next:{title:"How completeWork works",permalink:"/how-react-works/docs/react-dom/how.complete_work.works"}},u={},h=[{value:"Introduction",id:"introduction",level:2},{value:"Context",id:"context",level:2},{value:"<code>ReactCurrentDispatcher</code>",id:"reactcurrentdispatcher",level:2},{value:"How hooks are modelled",id:"how-hooks-are-modelled",level:2},{value:"Hooks examples",id:"hooks-examples",level:3},{value:"How hooks on mount work",id:"how-hooks-on-mount-work",level:2},{value:"<code>mountWorkInProgressHook</code> Implementation",id:"mountworkinprogresshook-implementation",level:3},{value:"How hooks on update work",id:"how-hooks-on-update-work",level:2},{value:"How hooks on rerender work",id:"how-hooks-on-rerender-work",level:2},{value:"How each hook works",id:"how-each-hook-works",level:2},{value:"How use works",id:"how-use-works",level:3},{value:"How useCallback works",id:"how-usecallback-works",level:3},{value:"How useEffect works",id:"how-useeffect-works",level:3},{value:"How useImperativeHandle works",id:"how-useimperativehandle-works",level:3},{value:"How useInsertionEffect works",id:"how-useinsertioneffect-works",level:3},{value:"How useLayoutEffect works",id:"how-uselayouteffect-works",level:3},{value:"How useMemo works",id:"how-usememo-works",level:3},{value:"How useReducer works",id:"how-usereducer-works",level:3},{value:"How useRef works",id:"how-useref-works",level:3},{value:"How useState works",id:"how-usestate-works",level:3},{value:"How useDebugValue works",id:"how-usedebugvalue-works",level:3},{value:"How useDeferredValue works",id:"how-usedeferredvalue-works",level:3},{value:"How useTransition works",id:"how-usetransition-works",level:3},{value:"How useSyncExternalStore works",id:"how-usesyncexternalstore-works",level:3},{value:"How useId works",id:"how-useid-works",level:3}],k={toc:h},c="wrapper";function d(e){let{components:t,...s}=e;return(0,r.kt)(c,(0,o.Z)({},k,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-hooks-work"},"How hooks work"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/hooks"},"Hooks")," were introduced in React\nv16.8.0, and since then they changed the way React apps were written.\nBefore them, we used to create class component for anything involving state\nor lifecycle logic.\nHooks made function component the new defacto of writing react apps."),(0,r.kt)("p",null,"They were a huge addition that simplified a lot of things. I am not stating here\nthat they are better than class components, but they offer a simpler way\nto reason about components and to deal with them, and especially they allow\nescaping dealing with ",(0,r.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,r.kt)("p",null,"This is not an explanation of React hooks themselves as they are pretty well\ndocumented in the official documentation. We will see how they are written\ninto React."),(0,r.kt)("h2",{id:"context"},"Context"),(0,r.kt)("p",null,"In the previous sections, precisely in how function components get rendered;\nwe've seen that we set a ",(0,r.kt)("inlineCode",{parentName:"p"},"Dispatcher")," based on whether your component is\nmounting for the first time or updating. So first, let's demystify this\ndispatcher."),(0,r.kt)("h2",{id:"reactcurrentdispatcher"},(0,r.kt)("inlineCode",{parentName:"h2"},"ReactCurrentDispatcher")),(0,r.kt)("p",null,"in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L556"},(0,r.kt)("inlineCode",{parentName:"a"},"renderWithHooks")),"\nfunction, we set the ",(0,r.kt)("inlineCode",{parentName:"p"},"ReactCurrentDispatcher.current"),". Which is a plain\njavascript object with all the hooks implementations that React has."),(0,r.kt)("p",null,"The goal of having the dispatcher object is to limit the behavior of your hooks'\nusage:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You use hooks outside the render phase: This means that hooks\nwon't work if you just decide to call the function component manually when\nReact isn't rendering. You are probably familiar with the thrown error."),(0,r.kt)("li",{parentName:"ul"},"Hooks behavior on mount and update isn't the same: as we will see later in\nthis section, on mount, the main goal of the dispatcher is to ",(0,r.kt)("inlineCode",{parentName:"li"},"reserve")," as\nplace for your hook call and initialize it, but on update it will perform\nthe update logic which is different.")),(0,r.kt)("p",null,"Like we said, the dispatcher contains as many properties as React hooks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"export const AllDispatchers: Dispatcher = {\n  readContext,\n\n  use,\n  useCallback: hook,\n  useContext: hook,\n  useEffect: hook,\n  useImperativeHandle: hook,\n  useInsertionEffect: hook,\n  useLayoutEffect: hook,\n  useMemo: hook,\n  useReducer: hook,\n  useRef: hook,\n  useState: hook,\n  useDebugValue: hook,\n  useDeferredValue: hook,\n  useTransition: hook,\n  useSyncExternalStore: hook,\n  useId: hook,\n};\n")),(0,r.kt)("p",null,"There are several dispatchers, but we will only discuss the main four:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ContextOnlyDispatcher"),": ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3408"},"This dispatcher"),"\nwill prevent you from using hooks outside the render phase. It will throw the\nfamous ",(0,r.kt)("inlineCode",{parentName:"li"},"Invalid hook call")," ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L440"},"error.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HooksDispatcherOnMount"),": ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3446"},"This dispatcher"),"\ncontains hooks implementation for components when mounting for the first time."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HooksDispatcherOnUpdate"),": ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3484"},"This dispatcher"),"\ncontains hooks implementation for components when they are updating."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HooksDispatcherOnRerender"),": ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3522"},"This dispatcher"),"\ncontains hooks implementation when components are re-rendering: when they\nperform a render phase update or when they rendered twice in dev mode.")),(0,r.kt)("h2",{id:"how-hooks-are-modelled"},"How hooks are modelled"),(0,r.kt)("p",null,"Each function component may have calls for any of the supported hooks. Remember,\nall hooks calls occur withing the ",(0,r.kt)("inlineCode",{parentName:"p"},"renderWithHooks")," function (exception for\nthe hooks for re-renders, they are called from within the ",(0,r.kt)("inlineCode",{parentName:"p"},"renderWithHooksAgain"),"\nfunction)."),(0,r.kt)("p",null,"Hooks are store into the ",(0,r.kt)("inlineCode",{parentName:"p"},"memoizedState")," property of the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L965"},"related ",(0,r.kt)("inlineCode",{parentName:"a"},"Fiber"),".")),(0,r.kt)("p",null,"A hook is stored inside React as a plain object with the following properties:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const hook: Hook = {\n  memoizedState: null,\n  \n  baseState: null,\n  baseQueue: null,\n  queue: null,\n  \n  next: null,\n};\n")),(0,r.kt)("p",null,"Where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"memoizedState"),': contains the hook "state" (or value)'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"baseState"),": used by state hooks to store the initial value"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"baseQueue"),":"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queue"),":"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"next"),": the next hook.")),(0,r.kt)("p",null,"As you may have guessed, the ",(0,r.kt)("inlineCode",{parentName:"p"},"next")," property references in the next hook your\ncomponent uses. Thus, hooks are modelled as a linked list of the previous\ndata structure."),(0,r.kt)("p",null,"Each hook have its own specification when it comes to what it stores inside\nthese properties, some hooks don't use all of these properties, obviously."),(0,r.kt)("p",null,"Notice how this data structure doesn't contain any information about the hook\nbeing used, hooks relies on call order and should ALWAYS be preserved."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"fiber and hook",src:n(4675).Z,width:"671",height:"444"})),(0,r.kt)("p",null,"Dan Abramov wrote an ",(0,r.kt)("a",{parentName:"p",href:"https://overreacted.io/why-do-hooks-rely-on-call-order/"},"outstanding blog post"),"\nexplaining this design choice."),(0,r.kt)("h3",{id:"hooks-examples"},"Hooks examples"),(0,r.kt)("p",null,"Assuming we are rendering the following component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function MyFunctionComponent(props) {\n  const [count, setCount] = React.useState(0);\n  // please don't do this, this is only for demo purposes\n  const isMounted = React.useRef(false);\n  // please don't do this, this is only for demo purposes\n  const mountDate = React.useMemo(() => Date.now(), []);\n  \n  React.useEffect(() => {\n    function handler() {\n      console.log('window is focused')\n    }\n    \n    window.addEventListener(\"focus\", handler);\n    return () => window.removeEventListener(\"focus\", handler);\n  }, []);\n  \n  return <span>Count is {count}</span>\n}\n")),(0,r.kt)("p",null,"Rendering this component will result in having a ",(0,r.kt)("inlineCode",{parentName:"p"},"Fiber")," of tag\n",(0,r.kt)("inlineCode",{parentName:"p"},"FunctionComponent")," with the following hooks linked list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'let memoizedState = {\n  // useState\n  "memoizedState": 0,\n  "baseState": 0,\n  "baseQueue": null,\n  "queue": {\n    "pending": null,\n    "lanes": 0,\n    "lastRenderedState": 0\n  },\n  "next": {\n    // useRef\n    "memoizedState": {\n      "current": false\n    },\n    "baseState": null,\n    "baseQueue": null,\n    "queue": null,\n    "next": {\n      // useMemo\n      "memoizedState": [\n        1700218172414,\n        []\n      ],\n      "baseState": null,\n      "baseQueue": null,\n      "queue": null,\n      "next": {\n        // useEffect\n        "memoizedState": {\n          "tag": 9,\n          "inst": {},\n          "deps": [],\n          "next": "the same effect .. removed for clarity"\n        },\n        "baseState": null,\n        "baseQueue": null,\n        "queue": null,\n        "next": null\n      }\n    }\n  }\n}\n')),(0,r.kt)("h2",{id:"how-hooks-on-mount-work"},"How hooks on mount work"),(0,r.kt)("p",null,"The purpose on hooks on mount as stated before is to grab a place in the linked\nlist of the hooks."),(0,r.kt)("p",null,"So, all hooks implementations on mount will first perform the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const hook = mountWorkInProgressHook();\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"mountWorkInProgressHook")," function will create the previous data structure\nand then set is as the ",(0,r.kt)("inlineCode",{parentName:"p"},"memoizedState")," property of the ",(0,r.kt)("inlineCode",{parentName:"p"},"currentlyRenderingFiber"),"."),(0,r.kt)("h3",{id:"mountworkinprogresshook-implementation"},(0,r.kt)("inlineCode",{parentName:"h3"},"mountWorkInProgressHook")," Implementation"),(0,r.kt)("p",null,"The mount in progress hook function is implemented as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"First, it will create the hook object"),(0,r.kt)("li",{parentName:"ul"},"Then, if it is the first hook of the list, it will attach it to the\n",(0,r.kt)("inlineCode",{parentName:"li"},"memoizedState")," of the ",(0,r.kt)("inlineCode",{parentName:"li"},"currentlyRenderingFiber")," and set this hook at the\n",(0,r.kt)("inlineCode",{parentName:"li"},"workInProgressHook")),(0,r.kt)("li",{parentName:"ul"},"Or else, it will attach it to the ",(0,r.kt)("inlineCode",{parentName:"li"},"next")," property of the ",(0,r.kt)("inlineCode",{parentName:"li"},"workInProgressHook"),".")),(0,r.kt)("p",null,"And that's it!"),(0,r.kt)("p",null,"Depending on the hook, other things will be performed, we will see them\nseparately for each supported hook."),(0,r.kt)("h2",{id:"how-hooks-on-update-work"},"How hooks on update work"),(0,r.kt)("p",null,"When your component is updating (not its first ever render), each supported\nhook call will start with the following expression then will follow up with\nthe specific work."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const hook = updateWorkInProgressHook();\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L973"},(0,r.kt)("inlineCode",{parentName:"a"},"updateWorkInProgressHook")),"\nis a bit more complex than the mount one, but its purpose it to detect the next\n",(0,r.kt)("inlineCode",{parentName:"p"},"workInProgressHook")," too. it used for both updates and re-renders, so it assumes\nthat there is either a ",(0,r.kt)("inlineCode",{parentName:"p"},"current")," hook object that can be cloned or a\n",(0,r.kt)("inlineCode",{parentName:"p"},"work-in-progress")," from a previous render that can be reused."),(0,r.kt)("p",null,"The first part of this function then is to find the currently rendered hook\nvalue. It will check the ",(0,r.kt)("inlineCode",{parentName:"p"},"current")," rendered fiber's ",(0,r.kt)("inlineCode",{parentName:"p"},"memoizedState"),"\nproperty if the ",(0,r.kt)("inlineCode",{parentName:"p"},"currentHook")," module variable is null, or else it takes its\n",(0,r.kt)("inlineCode",{parentName:"p"},"next")," property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// at module level:\nlet currentHook: null | Hook = null;\n\n// inside updateWorkInProgressHook\n\nlet nextCurrentHook: null | Hook;\nif (currentHook === null) {\n  // the current rendered fiber\n  const current = currentlyRenderingFiber.alternate;\n  \n  // already mounted\n  if (current !== null) {\n    nextCurrentHook = current.memoizedState;\n  } else {\n    // first mount\n    nextCurrentHook = null;\n  }\n  \n} else {\n  nextCurrentHook = currentHook.next;\n}\n")),(0,r.kt)("p",null,"Now, after detecting the current rendered (painted) hook value, React will\nthen try to find its alternate (the being rendered one):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// at module level:\nlet workInProgressHook: null | Hook = null;\n\n// inside updateWorkInProgressHook\nlet nextWorkInProgressHook: null | Hook;\n\n// first hook of the list, take it from the being rendered fiber\nif (workInProgressHook === null) {\n  nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n} else {\n  // or else, it is the next hook\n  nextWorkInProgressHook = workInProgressHook.next;\n}\n")),(0,r.kt)("p",null,"It is important to note that when we start updating a component, the memoized\nstate property is reset and set to null."),(0,r.kt)("p",null,"Now, we have the currently painted hook value, and the being rendered one."),(0,r.kt)("p",null,"When there is a ",(0,r.kt)("inlineCode",{parentName:"p"},"nextWorkInProgressHook"),", this means that we already have\nstarted rendering then we are rendering again without committing and finishing\nthe render, and thus, we will reuse it as is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"if (nextWorkInProgressHook !== null) {\n  // There's already a work-in-progress. Reuse it.\n  workInProgressHook = nextWorkInProgressHook;\n  nextWorkInProgressHook = workInProgressHook.next;\n\n  currentHook = nextCurrentHook;\n}\n")),(0,r.kt)("p",null,"Or else, if the ",(0,r.kt)("inlineCode",{parentName:"p"},"nextCurrentHook")," is null, that we are rendering more hooks\nthan the previous render, which is against hooks rules, and then React will\nthrow an error.\nWhen ",(0,r.kt)("inlineCode",{parentName:"p"},"nextCurrentHook")," isn't null, this means that we should clone the previous\nhook and use it as a base:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// React code\n\nif (nextWorkInProgressHook !== null) {\n  // previous code\n} else {\n  if (nextCurrentHook === null) {\n    const currentFiber = currentlyRenderingFiber.alternate;\n    if (currentFiber === null) {\n      // This is the initial render. This branch is reached when the component\n      // suspends, resumes, then renders an additional hook.\n      // Should never be reached because we should switch to the mount dispatcher first.\n      throw new Error(\n              'Update hook called on initial render. This is likely a bug in React. Please file an issue.',\n      );\n    } else {\n      // This is an update. We should always have a current hook.\n      throw new Error('Rendered more hooks than during the previous render.');\n    }\n  }\n\n  currentHook = nextCurrentHook;\n\n  // clone from the currently painted hook\n  const newHook: Hook = {\n    memoizedState: currentHook.memoizedState,\n\n    baseState: currentHook.baseState,\n    baseQueue: currentHook.baseQueue,\n    queue: currentHook.queue,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list.\n    currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n  } else {\n    // Append to the end of the list.\n    workInProgressHook = workInProgressHook.next = newHook;\n  }\n}\n")),(0,r.kt)("h2",{id:"how-hooks-on-rerender-work"},"How hooks on rerender work"),(0,r.kt)("p",null,"Re-rendering components is an internal term in the React codebase that means\nthat the component either scheduled a render phase update or that we are\nreplaying it in development mode."),(0,r.kt)("p",null,"If you take a close look at the ",(0,r.kt)("inlineCode",{parentName:"p"},"HooksDispatcherOnRerender")," dispatcher, you will\nnotice that it is the same as the ",(0,r.kt)("inlineCode",{parentName:"p"},"HooksDispatcherOnUpdate")," except for:\n",(0,r.kt)("inlineCode",{parentName:"p"},"useReducer: rerenderReducer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"useState: rerenderState"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"useDeferredValue: rerenderDeferredValue")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"useTransition: rerenderTransition"),"."),(0,r.kt)("p",null,"This dispatcher is set from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L771"},(0,r.kt)("inlineCode",{parentName:"a"},"renderWithHooksAgain")),"\nfunction. I will just copy Andrew's comment about this function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// This is used to perform another render pass. It's used when setState is\n// called during render, and for double invoking components in Strict Mode\n// during development.\n//\n// The state from the previous pass is reused whenever possible. So, state\n// updates that were already processed are not processed again, and memoized\n// functions (`useMemo`) are not invoked again.\n//\n// Keep rendering in a loop for as long as render phase updates continue to\n// be scheduled. Use a counter to prevent infinite loops.\n")),(0,r.kt)("h2",{id:"how-each-hook-works"},"How each hook works"),(0,r.kt)("p",null,"We will follow the presence of hooks in the dispatchers order to explain them."),(0,r.kt)("h3",{id:"how-use-works"},"How use works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-usecallback-works"},"How useCallback works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-useeffect-works"},"How useEffect works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-useimperativehandle-works"},"How useImperativeHandle works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-useinsertioneffect-works"},"How useInsertionEffect works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-uselayouteffect-works"},"How useLayoutEffect works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-usememo-works"},"How useMemo works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-usereducer-works"},"How useReducer works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-useref-works"},"How useRef works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-usestate-works"},"How useState works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-usedebugvalue-works"},"How useDebugValue works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-usedeferredvalue-works"},"How useDeferredValue works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-usetransition-works"},"How useTransition works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-usesyncexternalstore-works"},"How useSyncExternalStore works"),(0,r.kt)(a.Z,{mdxType:"TBD"}),(0,r.kt)("h3",{id:"how-useid-works"},"How useId works"),(0,r.kt)(a.Z,{mdxType:"TBD"}))}d.isMDXComponent=!0},4675:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/10.fiber_and_hook-e0e8b8ce545dbc127cc01d093c7dd427.png"}}]);