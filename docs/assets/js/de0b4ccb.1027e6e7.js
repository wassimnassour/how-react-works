"use strict";(self.webpackChunkhowreactworks=self.webpackChunkhowreactworks||[]).push([[399],{7522:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var r=t(9901);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),u=a,m=d["".concat(s,".").concat(u)]||d[u]||h[u]||o;return t?r.createElement(m,i(i({ref:n},p),{},{components:t})):r.createElement(m,i({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8284:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=t(3909),a=(t(9901),t(7522));const o={sidebar_position:7},i="How beginWork works",l={unversionedId:"react-dom/how.begin_work.works",id:"react-dom/how.begin_work.works",title:"How beginWork works",description:"Begin works is the function in React that will render your application.",source:"@site/docs/react-dom/6.how.begin_work.works.md",sourceDirName:"react-dom",slug:"/react-dom/how.begin_work.works",permalink:"/how-react-works/docs/react-dom/how.begin_work.works",draft:!1,editUrl:"https://github.com/incepter/how-react-works/edit/main/packages/howreactworks/docs/react-dom/6.how.begin_work.works.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"reactSidebar",previous:{title:"How the work loop works",permalink:"/how-react-works/docs/react-dom/how.work_loop.works"},next:{title:"How Rendering components works",permalink:"/how-react-works/docs/react-dom/how.rendering_components.works"}},s={},c=[{value:"Signature",id:"signature",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Attempt early bailout if applicable",id:"attempt-early-bailout-if-applicable",level:3},{value:"Render the components",id:"render-the-components",level:3},{value:"Cloning the <code>updateQueue</code>",id:"cloning-the-updatequeue",level:4},{value:"Processing the update queue",id:"processing-the-update-queue",level:4},{value:"How <code>reconcileChildFibersImpl</code> works",id:"how-reconcilechildfibersimpl-works",level:3},{value:"how <code>reconcileSingleElement</code> works",id:"how-reconcilesingleelement-works",level:3},{value:"Recap",id:"recap",level:2}],p={toc:c},d="wrapper";function h(e){let{components:n,...t}=e;return(0,a.kt)(d,(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"how-beginwork-works"},"How beginWork works"),(0,a.kt)("p",null,"Begin works is the function in React that will render your application."),(0,a.kt)("p",null,"We invoked it in the previous section like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  const current = unitOfWork.alternate;\n\n  // current: the original fiber: what's visible on the screen\n  // unitOfWork: the alternate fiber: the current ongoing render\n  // renderLanes: were globally assigned in prepareFreshStack\n  // highlight-next-line\n  const next = beginWork(current, unitOfWork, renderLanes);\n  \n  // ... rest of the code\n}\n\n")),(0,a.kt)("h2",{id:"signature"},"Signature"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"beingWork")," is defined ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/eaa696876ee40bb048727aefe995be1bbb7384a8/packages/react-reconciler/src/ReactFiberBeginWork.js#L4002"},"as follows:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"function beginWork(\n  current: Fiber | null, // the current fiber's tree\n  workInProgress: Fiber, // the alternate\n  renderLanes: Lanes,\n): Fiber | null { /* [Not Native Code] */ }\n")),(0,a.kt)("p",null,"It returns the next unit of work, we will see how it calculates it. The next\nunit of work will be the alternate of the next current fiber."),(0,a.kt)("h2",{id:"implementation"},"Implementation"),(0,a.kt)("p",null,"React components can be rendered several times in their lifetime, the ",(0,a.kt)("inlineCode",{parentName:"p"},"alternate"),"\nis created for each render that occurs as a draft of the next version of the\ncomponent's output."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"beginWork"),"'s simplified version looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"function beginWork(\n  current,\n  wip,\n  lanes\n) {\n  if (current !== null) {\n    // this component is updating\n  } else {\n    // this component renders for the first time\n    \n  }\n}\n")),(0,a.kt)("h3",{id:"attempt-early-bailout-if-applicable"},"Attempt early bailout if applicable"),(0,a.kt)("p",null,"So ",(0,a.kt)("inlineCode",{parentName:"p"},"beginWork")," will first check if we deal with a re-render, this is not the\ncase when coming from ",(0,a.kt)("inlineCode",{parentName:"p"},"root.render()")," but we will get into it anyway. Because\nthis code path is visited at every render."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Even when coming from ",(0,a.kt)("inlineCode",{parentName:"p"},"root.render"),", the ",(0,a.kt)("inlineCode",{parentName:"p"},"HostRoot")," fiber will have the\n",(0,a.kt)("inlineCode",{parentName:"p"},"alternate")," created since we created it when preparing a fresh stack. But not\nthe rest of the tree.")),(0,a.kt)("p",null,"So, when the alternate already exists:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Reference the ",(0,a.kt)("inlineCode",{parentName:"p"},"oldProps")," (",(0,a.kt)("inlineCode",{parentName:"p"},"current.memoizedProps"),") and ",(0,a.kt)("inlineCode",{parentName:"p"},"newProps")," (\n",(0,a.kt)("inlineCode",{parentName:"p"},"alternate(wip).pendingProps"),"):"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const oldProps = current.memoizedProps;\nconst newProps = workInProgress.pendingProps;\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If the ",(0,a.kt)("inlineCode",{parentName:"p"},"oldProps")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"newProps")," aren't the same (meaning a triggered render\nfrom the parent component) or the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/eaa696876ee40bb048727aefe995be1bbb7384a8/packages/react-reconciler/src/ReactFiberBeginWork.js#L4032"},"legacy context changed,"),"\nthen it mark the component as did receive update.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"When props did change, it will check if there is a scheduled update or some\ncontext changed:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The component received an update means that the alternate ",(0,a.kt)("inlineCode",{parentName:"li"},"lanes")," intersect\nwith the ",(0,a.kt)("inlineCode",{parentName:"li"},"renderLanes")," (do a pause a think about it)."),(0,a.kt)("li",{parentName:"ul"},"Contexts are stored as ",(0,a.kt)("inlineCode",{parentName:"li"},"fiber.dependencies")," in a linked list, so it will\niterate through all of them and compare the context's value.")),(0,a.kt)("p",{parentName:"li"},"When nothing changed, React will attempt to ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/eaa696876ee40bb048727aefe995be1bbb7384a8/packages/react-reconciler/src/ReactFiberBeginWork.js#L3788"},"bail out the render"),"\nfor this component and its children if possible. We will see the bailout\nin its dedicated section.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"When the ",(0,a.kt)("inlineCode",{parentName:"p"},"current")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," (first render of a component),\nthen it will mark the component as it did not receive an update, then it will\nperform some hydration related stuff. This is out of our scope for now."))),(0,a.kt)("p",null,"Let's put the previous words into code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\nfunction beginWork(\n  current: Fiber | null, // the painted fiber if any (garanteed for HostRoot)\n  workInProgress: Fiber, // the pending rendered fiber\n  renderLanes: Lanes,\n) {\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n    \n    if (oldProps !== newProps || hasLegacyContextChanged()) {\n      didReceivedUpdate = true;\n    } else {\n      if (\n        hasScheduledUpdateOrContext(current, renderLanes) &&\n        // more on this later\n        (workInProgress.flags & DidCapture === NoFlags)\n      ) {\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n    // out of our scope code\n  }\n}\n")),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"As a recap, ",(0,a.kt)("inlineCode",{parentName:"p"},"beginWork")," would attempt to bail out the work if not needed.\nThis is not the only work bailout on React, we will see it several times again.")),(0,a.kt)("h3",{id:"render-the-components"},"Render the components"),(0,a.kt)("p",null,"Right next, React will perform a huge ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/eaa696876ee40bb048727aefe995be1bbb7384a8/packages/react-reconciler/src/ReactFiberBeginWork.js#L4098"},"switch statement"),"\nover ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/6396b664118442f3c2eae7bf13732fcb27bda98f/packages/react-reconciler/src/ReactWorkTags.js#L10"},(0,a.kt)("inlineCode",{parentName:"a"},"workInProgress.tag"),".")),(0,a.kt)("p",null,"The goal of this switch is to redirect to the right function that will perform\nthe render on the current fiber."),(0,a.kt)("p",null,"We will see the ",(0,a.kt)("inlineCode",{parentName:"p"},"workTag"),"s in details in the next section, so for now, let's\njust scratch the surface when coming from ",(0,a.kt)("inlineCode",{parentName:"p"},"root.render()"),". Then in the next\nsection, we will dive into the work tags and how they work before visiting\nthe render of each one of them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  \n  // previous code\n  \n  switch(workInProgress.tag) {\n    // case FunctionComponent:\n    // case ClassComponent:\n    // case IndeterminateComponent:\n    // highlight-next-line\n    case HostRoot:\n      // highlight-next-line\n      return updateHostRoot(current, workInProgress, renderLanes);\n    // case HostPortal:\n    // case HostComponent:\n    // case HostText:\n    // case Fragment:\n    // case Mode:\n    // case ContextConsumer:\n    // case ContextProvider:\n    // case ForwardRef:\n    // case Profiler:\n    // case SuspenseComponent:\n    // case MemoComponent:\n    // case SimpleMemoComponent:\n    // case LazyComponent:\n    // case IncompleteClassComponent:\n    // case DehydratedFragment:\n    // case SuspenseListComponent:\n    // case ScopeComponent:\n    // case OffscreenComponent:\n    // case LegacyHiddenComponent:\n    // case CacheComponent:\n    // case TracingMarkerComponent:\n    // case HostHoistable:\n    // case HostSingleton:\n  }\n\n  throw new Error(\n    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\n    'React. Please file an issue.',\n  );\n}\n")),(0,a.kt)("p",null,"So as you see, there is a case for every supported tag."),(0,a.kt)("p",null,"For the very first render while having the ",(0,a.kt)("inlineCode",{parentName:"p"},"HostRoot")," fiber, we'll return\n",(0,a.kt)("inlineCode",{parentName:"p"},"updateHostRoot(current, workInProgress, renderLanes)"),"."),(0,a.kt)("p",null,"Let's scratch ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/eaa696876ee40bb048727aefe995be1bbb7384a8/packages/react-reconciler/src/ReactFiberBeginWork.js#L1443"},(0,a.kt)("inlineCode",{parentName:"a"},"updateHostRoot")," too.")),(0,a.kt)("p",null,"PS: This illustrates the first ever render of the root."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"\nfunction updateHostRoot(\n  current: null | Fiber,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  // we will ignore this for now\n  pushHostRootContext(workInProgress);\n\n  // defensive guard; the root fiber always has the current and alternate\n  if (current === null) {\n    throw new Error('Should have a current fiber. This is a bug in React.');\n  }\n  \n  const nextProps = workInProgress.pendingProps; // nextProps is null\n  \n  const prevState = workInProgress.memoizedState; // { element: null }\n\n  const prevChildren = prevState.element; // prevChildren = null\n\n  // highlight-next-line\n  cloneUpdateQueue(current, workInProgress);\n  // highlight-next-line\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  \n  // let's stop here for now, since the next code would assume that\n  // the updateQueue processing is done and would use properties accordingly\n  // we will continue the code after explaining clone and process the queue\n}\n\n")),(0,a.kt)("h4",{id:"cloning-the-updatequeue"},"Cloning the ",(0,a.kt)("inlineCode",{parentName:"h4"},"updateQueue")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"updateQueue")," was defined in how ",(0,a.kt)("inlineCode",{parentName:"p"},"createRoot")," works and its pending\nshare queue was populated during how ",(0,a.kt)("inlineCode",{parentName:"p"},"root.render")," works."),(0,a.kt)("p",null,"Now, and assuming we reach this path from the first render and during the\nruntime of the app, ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/4bbac04cd3624962900bb7800ba4f9609d3a1fd3/packages/react-reconciler/src/ReactFiberClassUpdateQueue.js#L189"},"this function"),"\nwill attach a new cloned ",(0,a.kt)("inlineCode",{parentName:"p"},"updateQueue")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"alternate")," if it has the\n",(0,a.kt)("inlineCode",{parentName:"p"},"same queue")," as the ",(0,a.kt)("inlineCode",{parentName:"p"},"current")," ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"function cloneUpdateQueue<State>(\n  current: Fiber,\n  workInProgress: Fiber,\n): void {\n  // Clone the update queue from current. Unless it's already a clone.\n  const queue: UpdateQueue<State> = workInProgress.updateQueue;\n  const currentQueue: UpdateQueue<State> = current.updateQueue;\n  \n  if (queue === currentQueue) {\n    const clone: UpdateQueue<State> = {\n      baseState: currentQueue.baseState,\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\n      shared: currentQueue.shared, // shared.pending is what's intersting here\n      callbacks: null,\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\n")),(0,a.kt)("h4",{id:"processing-the-update-queue"},"Processing the update queue"),(0,a.kt)("p",null,"This process is long and very complex, I will simplify it a lot and move on\nbecause it is not that interesting at this stage, we will see it again."),(0,a.kt)("p",null,"This cloning and processing paths are achievable from ",(0,a.kt)("inlineCode",{parentName:"p"},"HostRoot"),"s,\n",(0,a.kt)("inlineCode",{parentName:"p"},"ClassComponent"),"s and the upcoming experimental ",(0,a.kt)("inlineCode",{parentName:"p"},"CacheComponent"),"s."),(0,a.kt)("p",null,"The pending queue being cyclic and has at most two entries, the most recent\nas the last. It will be disconnected and then processed in a big ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/4bbac04cd3624962900bb7800ba4f9609d3a1fd3/packages/react-reconciler/src/ReactFiberClassUpdateQueue.js#L536"},(0,a.kt)("inlineCode",{parentName:"a"},"while(true)")),"\nloop."),(0,a.kt)("p",null,"This section will be moved into the annex, it is highly complex and would take\na lot of time to be explained."),(0,a.kt)("p",null,"Here is a simplified version that would allow us continuing the render phase:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"\n// coming from root.render(), we have only one update in a cyclic way\nprepareTheOrderOfUpdatesToProcess();\n\nlet update = firstBaseUpdate;\nlet newState = queue.baseState;\ndo {\n  const queue = workInProgress.updateQueue;\n  // highlight-next-line\n  newState = getStateFromUpdate(wip, queue, update, newState, props);\n  \n  if (update.callback) {\n    queue.callbacks.push(update.callback);\n  }\n\n  // highlight-next-line\n  update = update.next;\n  \n  // no pending update\n  if (update === null) {\n    if (queue.shared.pending === null) {\n      // highlight-next-line\n      break;\n    } else {\n      update = appendPendingUpdates();\n    }\n  }\n} while (true);\n\nworkInProgress.lanes = newLanes;\nworkInProgress.memoizedState = newState;\n\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/4bbac04cd3624962900bb7800ba4f9609d3a1fd3/packages/react-reconciler/src/ReactFiberClassUpdateQueue.js#L383"},(0,a.kt)("inlineCode",{parentName:"a"},"getStateFromUpdate")),"\nwill switch over the ",(0,a.kt)("inlineCode",{parentName:"p"},"update.tag")," (update state for now), which will result in\na state with ",(0,a.kt)("inlineCode",{parentName:"p"},"{ element }")," containing the ",(0,a.kt)("inlineCode",{parentName:"p"},"children")," we gave to ",(0,a.kt)("inlineCode",{parentName:"p"},"root.render()"),"."),(0,a.kt)("p",null,"Let's now get back to ",(0,a.kt)("inlineCode",{parentName:"p"},"updateHostRoot"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"\nfunction updateHostRoot(\n  current: null | Fiber,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  // we will ignore this for now\n  pushHostRootContext(workInProgress);\n\n  // defensive guard; the root fiber always has the current and alternate\n  if (current === null) {\n    throw new Error('Should have a current fiber. This is a bug in React.');\n  }\n  const nextProps = workInProgress.pendingProps; // nextProps was null here\n  const prevState = workInProgress.memoizedState; // { element: null }\n  const prevChildren = prevState.element; // prevChildren = null\n\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n\n  // highlight-next-line\n  // we are here now\n\n  // nextState = {element: children, isDehydrated: false, cache: {...} }\n  const nextState: RootState = workInProgress.memoizedState;\n  const root: FiberRoot = workInProgress.stateNode;\n  const nextChildren = nextState.element;\n\n  // highlight-next-line\n  if (nextChildren === prevChildren) {\n    // highlight-next-line\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    // highlight-next-line\n  }\n  // highlight-next-line\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  \n  return workInProgress.child;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"bailoutOnAlreadyFinishedWork")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"reconcileChildren")," are key functions during\nrender and are called from many places, they deserve their own chapter."),(0,a.kt)("p",null,"During the first render, we won't pass through ",(0,a.kt)("inlineCode",{parentName:"p"},"bailoutOnAlreadyFinishedWork"),",\nbut ",(0,a.kt)("inlineCode",{parentName:"p"},"reconcileChildren")," is a key here! So let's ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/eaa696876ee40bb048727aefe995be1bbb7384a8/packages/react-reconciler/src/ReactFiberBeginWork.js#L326"},"scratch it too:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"\nexport function reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes,\n) {\n  // initial mount of fibers, HostRoot won't pass here\n  if (current === null) {\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    // highlight-next-line\n    workInProgress.child = reconcileChildFibers(\n      workInProgress, // the returnFiber (the parent of the children)\n      current.child, // the current painted first child\n      nextChildren, // the new first child\n      renderLanes, // the lanes used during this render (DefaultLane from root.render)\n    );\n  }\n}\n")),(0,a.kt)("p",null,"When processing the ",(0,a.kt)("inlineCode",{parentName:"p"},"HostRoot")," fiber, the current always exists and thus\n",(0,a.kt)("inlineCode",{parentName:"p"},"reconcileChildFibers")," will call ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L1485"},(0,a.kt)("inlineCode",{parentName:"a"},"reconcileChildFibers")),"\nwhich resets thenable counter then calls ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L1344"},(0,a.kt)("inlineCode",{parentName:"a"},"reconcileChildFibersImpl")),"\nwith the same arguments."),(0,a.kt)("h3",{id:"how-reconcilechildfibersimpl-works"},"How ",(0,a.kt)("inlineCode",{parentName:"h3"},"reconcileChildFibersImpl")," works"),(0,a.kt)("p",null,"This function is responsible for rendering the ",(0,a.kt)("inlineCode",{parentName:"p"},"children"),", like we saw earlier\nthe children can be of many forms, such as an ",(0,a.kt)("inlineCode",{parentName:"p"},"array")," of elements, ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),"...\nand so on."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"function reconcileChildFibersImpl(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChild: any,\n  lanes: Lanes,\n): Fiber | null {\n  // [Not Native Code]\n}\n")),(0,a.kt)("p",null,"Let dive into this function step by step:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Skip over unkeyed top level fragment"),(0,a.kt)("p",{parentName:"li"},"First, React will verify if you top level child is a ",(0,a.kt)("inlineCode",{parentName:"p"},"Fragment")," without a key\nprops. If that's the case, then it will ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L1364"},"skip over that ",(0,a.kt)("inlineCode",{parentName:"a"},"Fragment"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"// unkeyed top level fragment is know like this:\nconst isUnkeyedTopLevelFragment =\n   typeof newChild === 'object' &&\n   newChild !== null &&\n   newChild.type === REACT_FRAGMENT_TYPE &&\n   newChild.key === null;\n\nif (isUnkeyedTopLevelFragment) {\n  newChild = newChild.props.children;\n}\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"When the given children are a non-null object then it will switch over the\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L1370"},(0,a.kt)("inlineCode",{parentName:"a"},"$$typeof")," property."),"\nDan gave a great blog post ","[about this property]",".(",(0,a.kt)("a",{parentName:"p",href:"https://overreacted.io/why-do-react-elements-have-typeof-property/"},"https://overreacted.io/why-do-react-elements-have-typeof-property/"),")"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"if (typeof newChild === 'object' && newChild !== null) {\n  switch(newChild.$$typeof) {\n    case REACT_ELEMENT_TYPE: {\n      // highlight-next-line\n      return placeSingleChild(\n      // highlight-next-line\n        reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes)\n      );\n    }\n    case REACT_PORTAL_TYPE: {\n      // highlight-next-line\n      return placeSingleChild(\n      // highlight-next-line\n        reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes)\n      );\n    }\n    case REACT_LAZY_TYPE: {\n      // ignore for now\n    }\n  }\n}\nif (isArray(newChild)) {\n  // highlight-next-line\n  // this will be delayed to the future\n  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n}\n\nif (getIteratorFn(newChild)) {\n  // highlight-next-line\n  // this will be delayed to the future\n  return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n}\n")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L835"},(0,a.kt)("inlineCode",{parentName:"a"},"reconcileChildrenArray")),"\nand ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L1002"},(0,a.kt)("inlineCode",{parentName:"a"},"reconcileChildrenIterator")),"\nwill be revisited later.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"If the children are an object when a ",(0,a.kt)("inlineCode",{parentName:"p"},".then")," function property\n(",(0,a.kt)("inlineCode",{parentName:"p"},"async components \ud83d\ude09"),"), then the promise will be unwrapped and its result\nis given to ",(0,a.kt)("inlineCode",{parentName:"p"},"reconcileChildFibersImpl")," again:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},'if (typeof newChild.then === "function") {\n  return reconcileChildFibersImpl(\n    returnFiber,\n    currentFirstChild,\n    unwrapThenable(newChild),\n    lanes\n  );\n}\n')),(0,a.kt)("admonition",{parentName:"li",type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"Async components are experimental and not well-supported in the client\nsince any render will output a new Promise and thus remove the previous tree.\nDon't use them without a caching strategy (they were originally designed\nfor the server were they are invoked once per request.).")))),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"As you may have noticed already, the reconciliation passes before the actual\nrender."),(0,a.kt)("p",{parentName:"admonition"},"The goal of the reconciliation is to port the next tree to the alternate\nthat we created from the current."),(0,a.kt)("p",{parentName:"admonition"},"At this stage coming from ",(0,a.kt)("inlineCode",{parentName:"p"},"root.render()")," there is not even a Fiber created\nfor out children, so the first step will be to create it.")),(0,a.kt)("h3",{id:"how-reconcilesingleelement-works"},"how ",(0,a.kt)("inlineCode",{parentName:"h3"},"reconcileSingleElement")," works"),(0,a.kt)("p",null,"This is actually a part of the reconciliation which has its own section."),(0,a.kt)("p",null,"The first thing this function does it to verify from the ",(0,a.kt)("inlineCode",{parentName:"p"},"currentFirstChild"),"\nif ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," changed then it will remove the child by adding it\nto a ",(0,a.kt)("inlineCode",{parentName:"p"},"deletions")," property in the ",(0,a.kt)("inlineCode",{parentName:"p"},"parentFiber"),". This will keep track of\ndeleted fibers so that we can invoke their cleanup effects in the commit phase."),(0,a.kt)("p",null,"Next, this function will create and return a new fiber for our application:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const created = createFiberFromElement(element, returnFiber.mode, lanes);\n")),(0,a.kt)("p",null,"When coming from ",(0,a.kt)("inlineCode",{parentName:"p"},"root.render()"),", the first fiber created by this will be the\nthird of our journey:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The first is the current fiber attached to the fiber root"),(0,a.kt)("li",{parentName:"ul"},"The second is its alternate"),(0,a.kt)("li",{parentName:"ul"},"The third (at least) is for the first child we gave to ",(0,a.kt)("inlineCode",{parentName:"li"},"root.render()"))),(0,a.kt)("admonition",{type:"important"},(0,a.kt)("p",{parentName:"admonition"},"By now, we have two unexplained major sections:"),(0,a.kt)("ol",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ol"},"The big ",(0,a.kt)("inlineCode",{parentName:"li"},"switch-case")," in the ",(0,a.kt)("inlineCode",{parentName:"li"},"beginWork")," function, it will be explained in\nthe ",(0,a.kt)("inlineCode",{parentName:"li"},"how rendering works")," section."),(0,a.kt)("li",{parentName:"ol"},"How ",(0,a.kt)("inlineCode",{parentName:"li"},"reconcileSingleElement")," works and how fibers are created, which will be\nexplained in the how ",(0,a.kt)("inlineCode",{parentName:"li"},"the reconciliation works")," section.")),(0,a.kt)("p",{parentName:"admonition"},"To avoid making this section very huge, we will move them next.")),(0,a.kt)("h2",{id:"recap"},"Recap"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"beginWork")," is called inside ",(0,a.kt)("inlineCode",{parentName:"p"},"performUnitOfWork(workInProgress)")," which will\nbe responsible for reconciling the children for the next tree before rendering\nit."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified in renderSync\nwhile(unitOfWork !== null) {\n  performUnitOfWork(unitOfWork);\n}\n\n\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (oldProps !== newProps || hasLegacyContextChanged()) {\n      didReceivedUpdate = true;\n    } else {\n      if (\n              hasScheduledUpdateOrContext(current, renderLanes) &&\n              // more on this later\n              (workInProgress.flags & DidCapture === NoFlags)\n      ) {\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(\n                current,\n                workInProgress,\n                renderLanes,\n        );\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n    // out of our scope code\n  }\n  \n  switch(workInProgress.tag) {\n    // case FunctionComponent:\n    // case ClassComponent:\n    // case IndeterminateComponent:\n    // highlight-next-line\n    case HostRoot:\n      // highlight-next-line\n      return updateHostRoot(current, workInProgress, renderLanes);\n    // case HostPortal:\n    // case HostComponent:\n    // case HostText:\n    // case Fragment:\n    // case Mode:\n    // case ContextConsumer:\n    // case ContextProvider:\n    // case ForwardRef:\n    // case Profiler:\n    // case SuspenseComponent:\n    // case MemoComponent:\n    // case SimpleMemoComponent:\n    // case LazyComponent:\n    // case IncompleteClassComponent:\n    // case DehydratedFragment:\n    // case SuspenseListComponent:\n    // case ScopeComponent:\n    // case OffscreenComponent:\n    // case LegacyHiddenComponent:\n    // case CacheComponent:\n    // case TracingMarkerComponent:\n    // case HostHoistable:\n    // case HostSingleton:\n  }\n\n  throw new Error(\n    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\n    'React. Please file an issue.',\n  );\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"updateHostRoot")," will process the updateQueue of our top level root object,\nwhich will result in a new tree to be rendered. Which is what we will see in the\nnext section."))}h.isMDXComponent=!0}}]);