"use strict";(self.webpackChunkhowreactworks=self.webpackChunkhowreactworks||[]).push([[890],{7522:(e,n,t)=>{t.d(n,{Zo:()=>h,kt:()=>m});var r=t(9901);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function a(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=r.createContext({}),s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},h=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,c=e.parentName,h=a(e,["components","mdxType","originalType","parentName"]),d=s(t),u=i,m=d["".concat(c,".").concat(u)]||d[u]||p[u]||l;return t?r.createElement(m,o(o({ref:n},h),{},{components:t})):r.createElement(m,o({ref:n},h))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,o=new Array(l);o[0]=u;var a={};for(var c in n)hasOwnProperty.call(n,c)&&(a[c]=n[c]);a.originalType=e,a[d]="string"==typeof e?e:i,o[1]=a;for(var s=2;s<l;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},2743:(e,n,t)=>{t.d(n,{Z:()=>i});var r=t(9901);function i(){return r.createElement("div",{style:{padding:8,textDecoration:"Window"}},r.createElement("i",null,r.createElement("p",null,"This section is not available yet. Please",r.createElement("a",{href:"https://github.com/incepter/how-react-works/issues/new",target:"_blank"}," fill an issue.")),r.createElement("p",null,"While waiting for the newsletter, you can get notified when new content drops by following",r.createElement("a",{href:"https://x.com/incepterr",target:"_blank"}," me on X."))))}},8046:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>h});var r=t(3909),i=(t(9901),t(7522)),l=t(2743);const o={sidebar_position:8},a="How Reconciliation works",c={unversionedId:"react-dom/how.reconciliation.works",id:"react-dom/how.reconciliation.works",title:"How Reconciliation works",description:"While rendering, reconciliation is the progress of computing and affecting the",source:"@site/docs/react-dom/8.how.reconciliation.works.md",sourceDirName:"react-dom",slug:"/react-dom/how.reconciliation.works",permalink:"/how-react-works/docs/react-dom/how.reconciliation.works",draft:!1,editUrl:"https://github.com/incepter/how-react-works/edit/main/packages/howreactworks/docs/react-dom/8.how.reconciliation.works.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"reactSidebar",previous:{title:"How Rendering components works",permalink:"/how-react-works/docs/react-dom/how.rendering_components.works"},next:{title:"How Fibers creation works \u23f8\ufe0f",permalink:"/how-react-works/docs/react-dom/how.fiber_creation.works"}},s={};(0,i.kt)(l.Z,null);const h=[{value:"How <code>reconcileChildFibersImpl</code> works",id:"how-reconcilechildfibersimpl-works",level:2},{value:"How single child reconciliation works",id:"how-single-child-reconciliation-works",level:2},{value:"How <code>reconcileSingleElement</code> works",id:"how-reconcilesingleelement-works",level:3},{value:"<code>coerceRef</code>",id:"coerceref",level:4},{value:"How <code>reconcileSinglePortal</code> works",id:"how-reconcilesingleportal-works",level:3},{value:"How <code>placeSingleChild</code> works",id:"how-placesinglechild-works",level:3},{value:"How <code>reconcile lazy</code> works",id:"how-reconcile-lazy-works",level:3},{value:"How children array reconciliation works",id:"how-children-array-reconciliation-works",level:2},{value:"How <code>reconcileChildrenArray</code> works",id:"how-reconcilechildrenarray-works",level:3},{value:"How <code>reconcileChildrenIterator</code> works",id:"how-reconcilechildreniterator-works",level:3},{value:"How text nodes reconciliation works",id:"how-text-nodes-reconciliation-works",level:2}],d={toc:h},p="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(p,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-reconciliation-works"},"How Reconciliation works"),(0,i.kt)("p",null,"While rendering, reconciliation is the progress of computing and affecting the\nfirst child of the currently rendered fiber. This will go recursively until\nit reaches the bottom of the tree, then ",(0,i.kt)("inlineCode",{parentName:"p"},"completeWork")," will kick and start\nclimbing back."),(0,i.kt)("p",null,"The first ever call to the reconciliation in the lifetime of your app\nis when rendering the ",(0,i.kt)("inlineCode",{parentName:"p"},"HostRoot")," and we'd need to transition to the next child\nwhich is what you gave to ",(0,i.kt)("inlineCode",{parentName:"p"},"root.render()"),"."),(0,i.kt)("p",null,"Later on, reconciliation will follow the same mechanics and will always\ncompute the next children."),(0,i.kt)("h1",{id:"how-reconcilechildren-works"},"How ",(0,i.kt)("inlineCode",{parentName:"h1"},"reconcileChildren")," works"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/eaa696876ee40bb048727aefe995be1bbb7384a8/packages/react-reconciler/src/ReactFiberBeginWork.js#L326"},(0,i.kt)("inlineCode",{parentName:"a"},"reconcileChildren")),"\nwill be the entry point to this process:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"export function reconcileChildren(\n  current: Fiber | null, // the current painted fiber\n  workInProgress: Fiber, // its alternate\n  nextChildren: any, // the next children\n  renderLanes: Lanes, // the render lanes\n) {\n  if (current === null) {\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderLanes,\n    );\n  }\n}\n\nfunction reconcileChildFibers(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChild: any,\n  lanes: Lanes,\n) {\n  thenableIndexCounter = 0;\n  // highlight-next-line\n  const firstChildFiber = reconcileChildFibersImpl(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    lanes,\n  );\n  thenableState = null;\n  return firstChildFiber;\n}\n")),(0,i.kt)("p",null,"This function will call the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L1485"},(0,i.kt)("inlineCode",{parentName:"a"},"reconcileChildFibers")),"\ndefined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ReactChildFiber")," module."),(0,i.kt)("p",null,"We will omit talking about thenable for now for the clarity of this section."),(0,i.kt)("p",null,"Following up, ",(0,i.kt)("inlineCode",{parentName:"p"},"reconcileChildFibersImpl")," will be called with the same arguments."),(0,i.kt)("h2",{id:"how-reconcilechildfibersimpl-works"},"How ",(0,i.kt)("inlineCode",{parentName:"h2"},"reconcileChildFibersImpl")," works"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L1344"},"This function"),"\nwill first decide on the next children to use: It will skip over a top level\nFragment without a key property."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This is actually a gotcha!"),(0,i.kt)("p",{parentName:"admonition"},"React won't create fibers for top level components without a key prop.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"From the signature, we can deduce that the reconciliation goal actually\nis to translate a ",(0,i.kt)("inlineCode",{parentName:"p"},"ReactNode")," to its equivalent ",(0,i.kt)("inlineCode",{parentName:"p"},"Fiber"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"function reconcileChildFibersImpl(\n  returnFiber: Fiber, // the parent fiber\n  currentFirstChild: Fiber | null, // the currently painted first child's fiber\n  newChild: any, // the next react node\n  lanes: Lanes, // the render lanes\n): Fiber | null {\n  \n  const isUnkeyedTopLevelFragment =\n    typeof newChild === 'object' && // a react element, not an array of them\n    newChild !== null && // typeof null is object \ud83d\ude44\n    newChild.type === REACT_FRAGMENT_TYPE && // a Fragment\n    newChild.key === null; // key prop\n  \n  if (isUnkeyedTopLevelFragment) {\n    // highlight-next-line\n    newChild = newChild.props.children;\n  }\n\n  if (typeof newChild === 'object' && newChild !== null) {\n    // treat objects (react elements, arrays ...)\n  }\n\n  if (\n    (typeof newChild === 'string' && newChild !== '') ||\n    typeof newChild === 'number'\n  ) {\n    // treat text nodes\n  }\n\n  if (__DEV__) {\n    if (typeof newChild === 'function') {\n      warnOnFunctionType(returnFiber);\n    }\n  }\n  // Remaining cases are all treated as empty.\n  return deleteRemainingChildren(returnFiber, currentFirstChild);\n}\n")),(0,i.kt)("p",null,"When the received ",(0,i.kt)("inlineCode",{parentName:"p"},"newChild")," (",(0,i.kt)("inlineCode",{parentName:"p"},"nextChildren"),") is a non-null object, then there\nare two possibilities: either it is a single node, or a collection of them."),(0,i.kt)("p",null,"Here is how it distinguishes between them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"if (typeof newChild === 'object' && newChild !== null) {\n  // single child\n  switch (newChild.$$typeof) {\n    \n  }\n  \n  // collection of children\n  if (isArray(newChild)) {\n    \n  }\n  if (getIteratorFn(newChild)) {\n    \n  }\n  \n  // async components\n  if (typeof newChild.then === 'function') {\n    \n  }\n  throwOnInvalidObjectType(returnFiber, newChild);\n}\n")),(0,i.kt)("h2",{id:"how-single-child-reconciliation-works"},"How single child reconciliation works"),(0,i.kt)("p",null,"When we have only one child with a valid ",(0,i.kt)("inlineCode",{parentName:"p"},"$$typeof")," property, then the following\ncases are treated:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"switch (newChild.$$typeof) {\n  case REACT_ELEMENT_TYPE:\n    return placeSingleChild(\n      reconcileSingleElement(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        lanes,\n      ),\n    );\n  case REACT_PORTAL_TYPE:\n    return placeSingleChild(\n      reconcileSinglePortal(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        lanes,\n      ),\n    );\n  case REACT_LAZY_TYPE:\n    const payload = newChild._payload;\n    const init = newChild._init;\n    return reconcileChildFibers(\n      returnFiber,\n      currentFirstChild,\n      init(payload),\n      lanes,\n    );\n}\n")),(0,i.kt)("p",null,"The key functions used above are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"placeSingleChild")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reconcileSingleChild")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reconcileSinglePortal")),(0,i.kt)("li",{parentName:"ul"},"recurse on lazy types: this recursion will land mostly in the thenables case\nand then enter reconciliation again.")),(0,i.kt)("h3",{id:"how-reconcilesingleelement-works"},"How ",(0,i.kt)("inlineCode",{parentName:"h3"},"reconcileSingleElement")," works"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L1228-L1233"},"This function"),"\ncontinues to keep the same signature, but this time the newChild parameter\nis pretty well-known and is a ",(0,i.kt)("inlineCode",{parentName:"p"},"ReactElement"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"function reconcileSingleElement(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  element: ReactElement,\n  lanes: Lanes,\n): Fiber {\n  \n  const key = element.key; // upcoming key\n  let child = currentFirstChild;\n  \n  // loop over the previous tree to search for an element with the same key\n  while(child !== null) {\n    // compare key first\n    if (child.key === key) {\n      // after that, base logic on elementType\n      const elementType = element.type; // the new element type\n      \n    } else {\n      deleteChild(returnFiber, child);\n    }\n    \n    child = child.sibling;\n  }\n\n  if (element.type === REACT_FRAGMENT_TYPE) {\n    // ...\n  } else {\n    // ...\n  }\n  \n}\n")),(0,i.kt)("p",null,"As you can see, ",(0,i.kt)("inlineCode",{parentName:"p"},"reconcileSingleElement")," will first loop over the existing\nchildren and try to find the one with the same key."),(0,i.kt)("p",null,"If found, it will then test against the ",(0,i.kt)("inlineCode",{parentName:"p"},"element.type"),", it has a special path\nfor the Fragment type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"while (child !== null) {\n  if (child.key === key) {\n    const elementType = element.type;\n    if (elementType === REACT_FRAGMENT_TYPE) {\n      if (child.tag === Fragment) {\n        // here, we are re-rendering a previous component\n        // highlight-next-line\n        deleteRemainingChildren(returnFiber, child.sibling);\n        // highlight-next-line\n        const existing = useFiber(child, element.props.children);\n        existing.return = returnFiber;\n        // highlight-next-line\n        return existing;\n      }\n      // if not a fragment, then we fallthrough the deleteChild\n    } else {\n      // here, regular elements (not fragments)\n      if (\n        // the component stayed with same type\n        child.elementType === elementType ||\n          // special case for React.lazy\n          (typeof elementType === 'object' &&\n            elementType !== null &&\n            elementType.$$typeof === REACT_LAZY_TYPE &&\n            resolveLazy(elementType) === child.type)\n      ) {\n        // highlight-next-line\n        deleteRemainingChildren(returnFiber, child.sibling);\n        // highlight-next-line\n        const existing = useFiber(child, element.props);\n        // highlight-next-line\n        existing.ref = coerceRef(returnFiber, child, element);\n        existing.return = returnFiber;\n        // highlight-next-line\n        return existing;\n      }\n    }\n    deleteRemainingChildren(returnFiber, child);\n    break; \n  } else {\n    // highlight-next-line\n    deleteChild(returnFiber, child);\n  }\n\n  // highlight-next-line\n  child = child.sibling;\n}\n")),(0,i.kt)("p",null,"So when found, React would ",(0,i.kt)("inlineCode",{parentName:"p"},"deleteRemainingChildren")," then clone the existing\nfiber and attach it to its parent (",(0,i.kt)("inlineCode",{parentName:"p"},"returnFiber"),") then return it.\nFragment doesn't have a ref, so the ",(0,i.kt)("inlineCode",{parentName:"p"},"coerceRef")," part isn't there."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L306"},(0,i.kt)("inlineCode",{parentName:"a"},"deleteRemainingChildren")),"\nwill remove all fibers from the children array of the return fiber starting\nfrom the given one."),(0,i.kt)("p",null,"The process removal will add the deleted fiber to the ",(0,i.kt)("inlineCode",{parentName:"p"},"deletions")," property of\nits parent:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// simplified\nfunction deleteRemainingChildren(\n        returnFiber: Fiber,\n        currentFirstChild: Fiber | null,\n): null {\n  let childToDelete = currentFirstChild;\n  while (childToDelete !== null) {\n    deleteChild(returnFiber, childToDelete);\n    childToDelete = childToDelete.sibling;\n  }\n  return null;\n}\n\nfunction deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {\n  const deletions = returnFiber.deletions;\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\n")),(0,i.kt)("p",null,"After dealing with the previous tree and if we didn't match yet, (on mount, there\nis no current tree, so we jump here from the start), then React will create a\nnew Fiber from the given React element and return it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"if (element.type === REACT_FRAGMENT_TYPE) {\n  const fiber = createFiberFromFragment(\n    element.props.children, // props\n          returnFiber.mode, // mode\n          lanes, // render lanes\n          element.key, // key\n  );\n  fiber.return = returnFiber;\n} else {\n  const created = createFiberFromElement(element, returnFiber.mode, lanes);\n  created.ref = coerceRef(returnFiber, currentFirstChild, element);\n  created.return = returnFiber;\n  return created;\n}\n")),(0,i.kt)("p",null,"The fiber creation is detailed in the next section, we will see how it goes for\nevery type."),(0,i.kt)("h4",{id:"coerceref"},(0,i.kt)("inlineCode",{parentName:"h4"},"coerceRef")),(0,i.kt)("h3",{id:"how-reconcilesingleportal-works"},"How ",(0,i.kt)("inlineCode",{parentName:"h3"},"reconcileSinglePortal")," works"),(0,i.kt)(l.Z,{mdxType:"TBD"}),(0,i.kt)("h3",{id:"how-placesinglechild-works"},"How ",(0,i.kt)("inlineCode",{parentName:"h3"},"placeSingleChild")," works"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/blob/afea1d0c536e0336735b0ea5c74f635527b65785/packages/react-reconciler/src/ReactChildFiber.js#L385"},(0,i.kt)("inlineCode",{parentName:"a"},"placeSingleChild")," function"),"\nwill mark the fiber of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Placement")," ",(0,i.kt)("inlineCode",{parentName:"p"},"flag")," when it is constructed for the first\ntime (no alternate)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"if (shouldTrackSideEffects && newFiber.alternate === null) {\n  newFiber.flags |= Placement | PlacementDEV;\n}\nreturn newFiber;\n")),(0,i.kt)("h3",{id:"how-reconcile-lazy-works"},"How ",(0,i.kt)("inlineCode",{parentName:"h3"},"reconcile lazy")," works"),(0,i.kt)(l.Z,{mdxType:"TBD"}),(0,i.kt)("h2",{id:"how-children-array-reconciliation-works"},"How children array reconciliation works"),(0,i.kt)(l.Z,{mdxType:"TBD"}),(0,i.kt)("h3",{id:"how-reconcilechildrenarray-works"},"How ",(0,i.kt)("inlineCode",{parentName:"h3"},"reconcileChildrenArray")," works"),(0,i.kt)(l.Z,{mdxType:"TBD"}),(0,i.kt)("h3",{id:"how-reconcilechildreniterator-works"},"How ",(0,i.kt)("inlineCode",{parentName:"h3"},"reconcileChildrenIterator")," works"),(0,i.kt)(l.Z,{mdxType:"TBD"}),(0,i.kt)("h2",{id:"how-text-nodes-reconciliation-works"},"How text nodes reconciliation works"),(0,i.kt)(l.Z,{mdxType:"TBD"}))}u.isMDXComponent=!0}}]);