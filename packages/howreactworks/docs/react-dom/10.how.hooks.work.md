---
sidebar_position: 10
---

# How hooks work

## Introduction
[Hooks](https://react.dev/reference/react/hooks) were introduced in React
v16.8.0, and since then they changed the way React apps were written.
Before them, we used to create class component for anything involving state
or lifecycle logic.
Hooks made function component the new defacto of writing react apps.

They were a huge addition that simplified a lot of things. I am not stating here
that they are better than class components, but they offer a simpler way
to reason about components and to deal with them, and especially they allow
escaping dealing with `this`.

This is not an explanation of React hooks themselves as they are pretty well
documented in the official documentation. We will see how they are written
into React.

## Context
In the previous sections, precisely in how function components get rendered;
we've seen that we set a `Dispatcher` based on whether your component is
mounting for the first time or updating. So first, let's demystify this
dispatcher.

## `ReactCurrentDispatcher`

in the [`renderWithHooks`](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L556)
function, we set the `ReactCurrentDispatcher.current`. Which is a plain
javascript object with all the hooks implementations that React has.

The goal of having the dispatcher object is to limit the behavior of your hooks'
usage:
- You use hooks outside the render phase: This means that hooks
  won't work if you just decide to call the function component manually when
  React isn't rendering. You are probably familiar with the thrown error.
- Hooks behavior on mount and update isn't the same: as we will see later in
  this section, on mount, the main goal of the dispatcher is to `reserve` as
  place for your hook call and initialize it, but on update it will perform
  the update logic which is different.

Like we said, the dispatcher contains as many properties as React hooks:

```tsx
export const AllDispatchers: Dispatcher = {
  readContext,

  use,
  useCallback: contextualImpelmentation,
  useContext: contextualImpelmentation,
  useEffect: contextualImpelmentation,
  useImperativeHandle: contextualImpelmentation,
  useInsertionEffect: contextualImpelmentation,
  useLayoutEffect: contextualImpelmentation,
  useMemo: contextualImpelmentation,
  useReducer: contextualImpelmentation,
  useRef: contextualImpelmentation,
  useState: contextualImpelmentation,
  useDebugValue: contextualImpelmentation,
  useDeferredValue: contextualImpelmentation,
  useTransition: contextualImpelmentation,
  useSyncExternalStore: contextualImpelmentation,
  useId: contextualImpelmentation,
};
```

There are several dispatchers, but we will only discuss the main four:

- `ContextOnlyDispatcher`: [This dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3408)
  will prevent you from using hooks outside the render phase. It will throw the
  famous `Invalid hook call` [error.](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L440)
- `HooksDispatcherOnMount`: [This dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3446)
  contains hooks implementation for components when mounting for the first time.
- `HooksDispatcherOnUpdate`: [This dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3484)
  contains hooks implementation for components when they are updating.
- `HooksDispatcherOnRerender`: [This dispatcher](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L3522)
  contains hooks implementation when components are re-rendering: when they
  perform a render phase update or when they rendered twice in dev mode.
  

## How hooks are modelled
Each function component may have calls for any of the supported hooks. Remember,
all hooks calls occur withing the `renderWithHooks` function (exception for
the hooks for re-renders, they are called from within the `renderWithHooksAgain`
function).

Hooks are store into the `memoizedState` property of the [related `Fiber`.](https://github.com/facebook/react/blob/77c4ac2ce88736bbdfe0b29008b5df931c2beb1e/packages/react-reconciler/src/ReactFiberHooks.js#L965)

A hook is stored inside React as a plain object with the following properties:

```tsx
const hook: Hook = {
  memoizedState: null,
  
  baseState: null,
  baseQueue: null,
  queue: null,
  
  next: null,
};
```

Where:
- `memoizedState`: contains the hook "state" (or value)
- `baseState`: used by state hooks to store the initial value
- `baseQueue`:
- `queue`:
- `next`: the next hook.

As you may have guessed, the `next` property references in the next hook your
component uses. Thus, hooks are modelled as a linked list of the previous
data structure.

Each hook have its own specification when it comes to what it stores inside
these properties, some hooks don't use all of these properties, obviously.

## How hooks on mount work
The purpose on hooks on mount as stated before is to grab a place in the linked
list of the hooks.

## How hooks on update work

## How hooks on rerender work

## How each hook works

### How use works
### How useCallback works
### How useEffect works
### How useImperativeHandle works
### How useInsertionEffect works
### How useLayoutEffect works
### How useMemo works
### How useReducer works
### How useRef works
### How useState works
### How useDebugValue works
### How useDeferredValue works
### How useTransition works
### How useSyncExternalStore works
### How useId works
